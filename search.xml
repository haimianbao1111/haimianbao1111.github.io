<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo 使用过程遇到的问题]]></title>
    <url>%2F2018%2F02%2F12%2FHexo-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述问题描述： 在hexo下新建一个MD文件，出现Template render error: unknown path?解决方案：1这个是hexo转义时候发生的错误，你文章中可能出现了&#123;&#123;&#125;&#125;，&#123;% %&#125;。你可以将出现的代码，用 `进行注释下就可以了.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础--浅谈XML读取以及简单的ORM实现]]></title>
    <url>%2F2018%2F02%2F12%2FC-%E5%9F%BA%E7%A1%80-%E6%B5%85%E8%B0%88XML%E8%AF%BB%E5%8F%96%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E7%9A%84ORM%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述背景: 在开发ASP.NETMVC4 项目中,虽然web.config配置满足了大部分需求,不过对于某些特定业务,我们有时候需要添加新的配置文件来记录配置信息,那么XML文件配置无疑是我们选择的一个方案之一。下面简单谈谈XML的读取。 使用一.xml.linq读取xml1.新建一个data.XML文件123456789101112&lt;Customers&gt; &lt;Customer&gt; &lt;Name&gt;Frank&lt;/Name&gt; &lt;City&gt;成都&lt;/City&gt; &lt;Contact&gt;2233&lt;/Contact&gt; &lt;/Customer&gt; &lt;Customer&gt; &lt;Name&gt;Vincent&lt;/Name&gt; &lt;City&gt;美国&lt;/City&gt; &lt;Contact&gt;4455&lt;/Contact&gt; &lt;/Customer&gt;&lt;/Customers&gt; 2.新建customer实体123456public class Customers&#123; public string Name &#123; get; set; &#125; public string City &#123; get; set; &#125; public string Contact &#123; get; set; &#125;&#125; 3.System.Xml.Linq 域名. 就可以轻松将customer信息读取完毕。XDocument.Load读取xml文件. Descendants可以读取Customer节点返回一个集合.再通过Linq的select方法.读取每个Customer节点数据,转换成List对象1234567var customsers = XDocument.Load(&quot;data.xml&quot;).Descendants(&quot;Customer&quot;) .Select(x =&gt; new Customers() &#123; Name = x.Element(&quot;Name&quot;).Value, City = x.Element(&quot;City&quot;).Value, Contact = x.Element(&quot;Contact&quot;).Value, &#125;).ToList(); 二. 简单的ORM上面介绍了XML的读取,那XML读取有没有可以更简单的方式呢. 比如类似于Database的ORM框架. 只需要实体名称与DB SQL的select字段名称一样就会自动映射到实体上面。不需要我们去写代码一个一个去Element上取。 下面我们就来简单实现一个。下面代码只是提供思路:其实我们可以通过反射和打标签来实现, 大家有空不妨去看看小弟写得两篇 打标签和反射的文章。C#基础—Attribute(标签） 和 reflect（反射) 应用C#基础—Attribute(标签） 和 reflect（反射) 应用二 1.新建XmlAttribute类。提供了ElementName属性用于标记实体类字段对应的xml节点12345678public class XmlAttribute : Attribute&#123; public string ElementName &#123; get; set; &#125;&#125; 2. 修改新建的Customler类.ElementName 对应的xml节点名称, 因为有可能开发者xml节点名称和实体名称不一样。1234567891011public class Customers&#123; [Xml(ElementName = &quot;Name&quot;)] public string Name &#123; get; set; &#125; [Xml(ElementName = &quot;City&quot;)] public string City &#123; get; set; &#125; [Xml(ElementName = &quot;Contact&quot;)] public string Contact &#123; get; set; &#125;&#125; 3. 提供XmlReader类,用于读取xml数据(1).先通过反射读取实体,比如Customer类的 字段名称和对应的xml节点名称存入到dic 字典里面.(2).遍历字段，取值赋给实体1234567891011121314151617181920212223242526272829303132333435363738public class XmlReader &#123; public static List&lt;T&gt; ReadList&lt;T&gt;(string filePath,string rootName) where T:class,new () &#123; List&lt;PropertyInfo&gt; propertyInfos = ((T)Activator.CreateInstance(typeof(T))).GetType().GetProperties().ToList(); List&lt;T&gt; result = new List&lt;T&gt;(); var xmlData = XDocument.Load(filePath); //存储实体 属性名称--xml对应节点名称 的key-value值 Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;(); propertyInfos .ForEach(property =&gt; &#123; var attribute = property.GetCustomAttribute(typeof(XmlAttribute)) as XmlAttribute; if (attribute != null) &#123; dic.Add(property.Name, attribute.ElementName); &#125; &#125;); return xmlData .Descendants(rootName) .Select(element =&gt; &#123; // 实例化一个对象 var info = (T)Activator.CreateInstance(typeof(T)); //遍历keyvalue字段,给实体每个字段赋值 foreach (KeyValuePair&lt;string, string&gt; pair in dic) &#123; // 读取对象的filed标签 var attr = info.GetType().GetProperty(pair.Key); attr.SetValue(info, element.Element(pair.Value).Value); &#125; return info; &#125;).ToList(); &#125; &#125; 4.下面看看结果吧, 轻松读取数据了 三. 总结本篇只是简简单单的谈了一下XML读取,xml的类型很多,比如在这些情况也没有考虑。此类情况如果要再次封装。就需要在XmlAttribute类新增一个AttributeName来实现。而且数据类型除开string,还有int，datetime等。以及xml的嵌套，多层解析xml数据等等。网上应该有很多读取xml的框架,我相信很多公司也会有自己的xml读取的框架。虽然没必要重造轮子。但是作为一个开发者还是可以去想想。如果自己要去开发这些公共框架，也应该知道怎么去做，知道可以通过什么方式去实现。 原文引自：http://www.cnblogs.com/FourLeafCloverZc/p/6565589.html]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Select2下拉框总结]]></title>
    <url>%2F2018%2F02%2F12%2FSelect2%E4%B8%8B%E6%8B%89%E6%A1%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、概述组件说明以及API说明：Select2使用示例地址：https://select2.github.io/examples.html Select2参数文档说明：https://select2.github.io/options.html Select2源码：https://github.com/select2/select2 二、组件特性效果展示1、多选效果 2、图文结合的效果 组件使用1、文件需要引入select2.full.js、select2.min.css（4.0.1版本）和jquery.1.8.3及以上最新版本的select2如果引用的jquery版本较低的话，某些功能无法正常使用。比如：清除功能allowClear: true 最新版本请使用标签 2、placeholderplaceholder占位提示文字，如果需要清楚功能，则必须设置placeholder。 3、加载本地数据select2默认的数据属性是id、text，新版本可以自定义，但还是用默认的比较好。所以提供的json中最好转换为id、text形式，当然可以添加其他属性。1234567891011var data = [&#123; id: 0, text: &apos;enhancement&apos; &#125;, &#123; id: 1, text: &apos;bug&apos; &#125;, &#123; id: 2, text: &apos;duplicate&apos; &#125;, &#123; id: 3, text: &apos;invalid&apos; &#125;, &#123; id: 4, text: &apos;wontfix&apos; &#125;];$(&quot;#c01-select&quot;).select2(&#123; data: data, placeholder:&apos;请选择&apos;, allowClear:true&#125;) 4、加载远程数据12345678910111213141516171819202122$(&quot;#c01-select&quot;).select2(&#123; ajax: &#123; url: &quot;data.json&quot;, dataType: &apos;json&apos;, delay: 250, data: function (params) &#123; return &#123; q: params.term, &#125;; &#125;, processResults: function (data) &#123; return &#123; results: data &#125;; &#125;, cache: true &#125;, escapeMarkup: function (markup) &#123; return markup; &#125;, minimumInputLength: 1, templateResult: formatRepo, templateSelection: formatRepoSelection &#125;); 说明：q: params.term 查询参数（params.term表示输入框中内容，q发生到服务器的参数名；所以这里你可以添加自定义参数，如：stype:’person’） processResults中results: data返回数据（返回最终数据给results，如果我的数据在data.res下，则返回data.res。这个与服务器返回json有关） minimumInputLength 最小需要输入多少个字符才进行查询，与之相关的maximumSelectionLength表示最大输入限制。 escapeMarkup字符转义处理 templateResult返回结果回调function formatRepo(repo){return repo.text},这样就可以将返回结果的的text显示到下拉框里，当然你可以return repo.text+”1”;等 templateSelection选中项回调function formatRepoSelection(repo){return repo.text} 关于返回的 json的格式：select2默认json格式为[{id:1,text:’text’},{id:2,text:’text’}]，新版严格要求这样的格式，当然你可以添加列，如：[{id:1,text:’text’,name:’liu’}] 5、获取选中项12345678910var res=$(&quot;#c01-select&quot;).select2(&quot;data&quot;)[0] ; //单选var reslist=$(&quot;#c01-select&quot;).select2(&quot;data&quot;); //多选if(res==undefined)&#123; alert(&quot;你没有选中任何项&quot;);&#125;if(reslist.length)&#123; alert(&quot;你选中任何项&quot;);&#125; 6、清空选择项和设置不可用1234567//清空选择$(&quot;#c01-select&quot;).val(null).trigger(&quot;change&quot;);$(&quot;#c01-select&quot;).val(&quot;你的placeholder&quot;).trigger(&quot;change&quot;);//或者//disabled$(&quot;#c01-select&quot;).prop(&quot;disabled&quot;, false);//可用$(&quot;#c01-select&quot;).prop(&quot;disabled&quot;, true);//不可用 7、启用多选1234$(&quot;#c01-select&quot;).select2(&#123; data:data, multiple: true&#125;); 8、下面简单说明新版与老版对比(1)结果回调和选中回调名称：formatResult、formatSelection（老版）；templateResult、templateSelection（新版） (2)初始化：12345678910//老版，注意如果初始化时文本框中本身没有值（为空），则不会触发该方法initSelection: function (element, callback) &#123; var id = $(element).val(); var data = &#123; id: id, text: id&#125;;//这里是初始化的数据，你可以通过id来从服务器上获取（ajax），再装载进去 callback(data);&#125;//新版，直接给select添加option$(&quot;#id&quot;).append(new Option(&quot;Jquery&quot;, 10001, false, true));//或者$(&quot;#id&quot;).append(&quot;&lt;option value=&apos;10001&apos;&gt;Jquery&lt;/option&gt;&quot;); (3)获取或设置值：12select2(&quot;val&quot;)（老版）；$(&quot;select&quot;).val()（新版） (4)推荐使用123var res = $(&quot;#id&quot;).select2(&quot;data&quot;);//返回数组，单选就取res[0]；好处是不进可以获取id、text还可以获取其他属性，如res[0].names (5)停用或启用：12$(&quot;select&quot;).enable(false);（老版）；$(&quot;select&quot;).prop(&quot;disabled&quot;, true);（新版） (6)主题样式：新版的样式已经更新，但如果想使用老版样式则可以设置 theme: “classic” 项目使用中遇到的问题My Demo实例代码(1)取值字符串的拼接123456789101112131415form.on(&apos;submit(save)&apos;, function (data) &#123; var htmlSelected = []; var reslist = $(&quot;#typeId&quot;).select2(&quot;data&quot;); for (var i = 0; i &lt; reslist.length; i++) &#123; htmlSelected.push($(&apos;#typeId&apos;).select2(&apos;data&apos;)[i].text); &#125; //标签信息。 data.field.Text_Tag = htmlSelected.join(&quot;,&quot;).toString(); $.formSubmit(&#123; url: &quot;/System/ArticleManage/RequestSave&quot;, data: data.field &#125;); return false;&#125;); 说明：放弃以前字符串”+”的拼接方式，改用声明数组，join(“,”)的拼接方式，这样省去字符末尾去空格的问题。性能方面也会比前者好很多。(2)赋值 12345//获取文章标签集合$(&quot;#typeId&quot;).bindSelect(&#123; url: &quot;/System/ArticleManage/GetListTreeSelect&quot;, title: &apos;请选择文章标签&apos;&#125;); Other Demo实例代码(1)取值1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; //取textvar strtext = $(&apos;#select2&apos;).select2(&apos;data&apos;).text;//取valuevar str2value= $(&quot;#select2&quot;).select2(&quot;val&quot;);//多选$(&apos;#select2&apos;).select2(&#123; allowClear: true, data:[&#123;id:0,text:&apos;hello&apos;&#125;,&#123;id:1,text:&apos;world&apos;&#125;]&#125;);&lt;/script&gt;&lt;select id=&quot;select2&quot; &gt; &lt;/select&gt;Select2升级以后，支持多选了，用select2(&apos;data&apos;)取出来是是数组，不在是一个json了，因需要select2(&apos;data&apos;)[0].text 既可以取得对应的值，多个的话循环获取 (2)赋值页面采用razor12345678910111213141516&lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;销售人员：&lt;/label&gt; @Html.DropDownListFor(m =&gt; m.SalesMan, ViewData[&quot;CreateStaffID&quot;] as SelectList, &quot;请选择&quot;, new &#123; @id = &quot;SalesMan&quot;, @class = &quot;select2 &quot;, @style = &quot;width:67%;&quot; &#125;) &lt;span class=&quot;help-line&quot;&gt;@Html.ValidationMessageFor(m =&gt; m.SalesMan)&lt;/span&gt;&lt;/div&gt;js:&lt;script type=&quot;text/javascript&quot;&gt; //示例：给select2标签赋值23 @Html.Raw(&quot;$(&apos;#SalesMan&apos;).val(&quot;23&quot;) $(&quot;#SalesMan&quot;).select2(); &#125;);&lt;/script&gt; 参考原文：http://www.cnblogs.com/liuxiaobo93/p/5112993.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.NET，C#和ASP.NET的关系]]></title>
    <url>%2F2018%2F02%2F08%2FC-%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[概述.NET是一个平台，一个抽象的平台的概念。.NET平台其本身实现的方式其实还是库，抽象层面上来看是一个平台。个人理解.NET核心就只是.NET Framework。.NET Framework包括了两个关键组成元素：Common Language Runtime， 公共语言运行时 －－提供内存管理、代码安全性检测等等功能。.NET Framework Class Library， .NET框架类库 －－提供大量应用类库、提高开发效率。 C#是一个程序设计语言，仅仅是一个语言。运行在.NET(CLR)上的，用于创建应用程序的一种高级编程语言。程序设计语言仅仅是为了方便开发人员和计算机沟通的工具，虽然C#语法相对C和C++要多一些，但是相对来看C#语法都比较固定，这样使用起来却都很容易。 ASP.NET是一个网站开发的技术，仅仅是.NET框架中的一个应用模型。用微软公司ASP.NET快速入门中的一句话来解释，ASP.NET 是用于生成基于 Web 的应用程序的内容丰富的编程框架。 ASP.net和C#的区别：编写asp.net通常包括两部分的代码:网页层和后台处理层.网页就是用标记语言来写的，而网页对应的后台处理程序则需要.net语言来完成，目前主要是采用c#和vb.net可以说整个的asp.net网站通过c#或者vb.net来实现。而c#则是ms .net framework的主要语言，可以用在网站，桌面应用等方面。可以算是一种比较流行的编程语言。 C#能编写什么样的应用程序?桌而应用释详：使用.Net Framework的Windows Presentation Foundation(WPF)模块就可以简便地生成这种程序。 WindowsStore应用程序:WIN8新引入的一类应用程序，针对触摸屏设计，通常全屏运行。 Web应用程序:它们是一些Web页面，可以通过任何Web浏览器查看。可以用C#语言通过Web Forms创建ASP.NET应用程序。 WCF服务:这是一种灵活创建各种分布式应用程巧的方式。使用 WCF服务可以通过局域网或Internet交换几乎各种数据。 .NET的两种交互模式主要有：B/SC/S]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将枚举值转换为DropDownList等的选项值]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%B0%86%E6%9E%9A%E4%B8%BE%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BADropDownList%E7%AD%89%E7%9A%84%E9%80%89%E9%A1%B9%E5%80%BC%2F</url>
    <content type="text"><![CDATA[概述应用场景：在项目中，我们已习惯将较稳定的分类标准定义为枚举，来保证程序中取值的合法性，也使代码更清晰。某些情况下我们需要在DropDownList等选择控件上绑定某个枚举的所有枚举值，供用户自行选择，这时就需要将枚举值转换为DropDownList等的选项值。 应用枚举定义1234567891011121314/// &lt;summary&gt;/// 紧急程度/// &lt;/summary&gt;public enum eOA_EmergencyLevel&#123; /// &lt;summary&gt; /// 平件 /// &lt;/summary&gt; 平件 = 1, /// &lt;summary&gt; /// 急件 /// &lt;/summary&gt; 急件 = 2&#125; 将枚举转换成ArrayList12345678910111213141516/// &lt;summary&gt;/// 将枚举转换成ArrayList/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IList EnumToList(Type enumType)&#123; ArrayList list = new ArrayList(); foreach (int i in Enum.GetValues(enumType)) &#123; ListItem listitem = new ListItem(Enum.GetName(enumType, i), i.ToString()); list.Add(listitem); &#125; return list;&#125; 绑定1234567891011/// &lt;summary&gt;/// 将枚举转换成下拉框/// &lt;/summary&gt;public static void FillDropDownList(DropDownList ddl, Type enumType)&#123; ddl.Items.Clear(); ddl.DataSource = EnumToList(enumType); ddl.DataValueField = &quot;value&quot;; ddl.DataTextField = &quot;text&quot;; ddl.DataBind();&#125; 后来，在同事讨论代码时，被大家批评为不该使用这种中文的枚举名称；同时我自己也觉得这种反射方式性能有问题。不过因为影响不大，一直懒得去理它。 最近看到了两篇博文（枚举的显示和绑定&gt;和一个利用扩展方法的实例：AttachDataExtensions ），是利用C# 3.0的扩展方法实现的，实现得很是优美，可惜我们的项目基于.NET 2.0，用不上。但受此启发，便花了点时间使用Attribute和缓存的技术重构了原来的代码。 改进EnumShowNameAttribute123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// 枚举的显示名称/// &lt;/summary&gt;[global::System.AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]public sealed class EnumShowNameAttribute : Attribute&#123; private string showName; /// &lt;summary&gt; /// 显示名称 /// &lt;/summary&gt; public string ShowName &#123; get &#123; return this.showName; &#125; &#125; /// &lt;summary&gt; /// 构造枚举的显示名称 /// &lt;/summary&gt; /// &lt;param name=&quot;showName&quot;&gt;显示名称&lt;/param&gt; public EnumShowNameAttribute(string showName) &#123; this.showName = showName; &#125;&#125;枚举定义/// &lt;summary&gt;/// 紧急程度/// &lt;/summary&gt;public enum eOA_EmergencyLevel&#123; /// &lt;summary&gt; /// 平件 /// &lt;/summary&gt; [EnumShowName(&quot;平件&quot;)] Common = 1, /// &lt;summary&gt; /// 急件 /// &lt;/summary&gt; [EnumShowName(&quot;急件&quot;)] Emergency = 2&#125; 枚举工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/// &lt;summary&gt;/// 枚举工具类/// &lt;/summary&gt;public sealed class EnumUtil&#123; private static Dictionary&lt;string, Dictionary&lt;int, string&gt;&gt; _EnumList = new Dictionary&lt;string, Dictionary&lt;int, string&gt;&gt;(); //枚举缓存池 /// &lt;summary&gt; /// 将枚举绑定到ListControl /// &lt;/summary&gt; /// &lt;param name=&quot;listControl&quot;&gt;ListControl&lt;/param&gt; /// &lt;param name=&quot;enumType&quot;&gt;枚举类型&lt;/param&gt; public static void FillListControl(ListControl listControl, Type enumType) &#123; listControl.Items.Clear(); listControl.DataSource = EnumToDictionary(enumType); listControl.DataValueField = &quot;key&quot;; listControl.DataTextField = &quot;value&quot;; listControl.DataBind(); &#125; /// &lt;summary&gt; /// 将枚举转换成Dictionary&amp;lt;int, string&amp;gt; /// Dictionary中，key为枚举项对应的int值；value为：若定义了EnumShowName属性，则取它，否则取name /// &lt;/summary&gt; /// &lt;param name=&quot;enumType&quot;&gt;枚举类型&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Dictionary&lt;int, string&gt; EnumToDictionary(Type enumType) &#123; string keyName = enumType.FullName; if (!_EnumList.ContainsKey(keyName)) &#123; Dictionary&lt;int, string&gt; list = new Dictionary&lt;int, string&gt;(); foreach (int i in Enum.GetValues(enumType)) &#123; string name = Enum.GetName(enumType, i); //取显示名称 string showName = string.Empty; object[] atts = enumType.GetField(name).GetCustomAttributes(typeof(EnumShowNameAttribute), false); if (atts.Length &gt; 0) showName = ((EnumShowNameAttribute)atts[0]).ShowName; list.Add(i, string.IsNullOrEmpty(showName) ? name : showName); &#125; object syncObj = new object(); if (!_EnumList.ContainsKey(keyName)) &#123; lock (syncObj) &#123; if (!_EnumList.ContainsKey(keyName)) &#123; _EnumList.Add(keyName, list); &#125; &#125; &#125; &#125; return _EnumList[keyName]; &#125; /// &lt;summary&gt; /// 获取枚举值对应的显示名称 /// &lt;/summary&gt; /// &lt;param name=&quot;enumType&quot;&gt;枚举类型&lt;/param&gt; /// &lt;param name=&quot;intValue&quot;&gt;枚举项对应的int值&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetEnumShowName(Type enumType, int intValue) &#123; return EnumToDictionary(enumType)[intValue]; &#125;&#125; 想更偷懒的话，还可以省掉自定义的EnumShowNameAttribute，直接用System.ComponentModel.DescriptionAttribute就行了。 [附]Enum基础知识：c# 枚举 enum.NET中Flags枚举的使用 关于枚举的种种 (Enumeration FAQ) [C#, IL, BCL] 原文链接：http://www.cnblogs.com/wenjian/archive/2009/06/19/1506550.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C#小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将字符串转换成List]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90List-T%2F</url>
    <content type="text"><![CDATA[概述有时需要将一个字符串分隔后，转换成指定类型的数组或List，比如服务器端收到提交的一组checkbox的值，可能是一个ID串，类似：56,657,0,1,2,3,4,5,6,7,8，需要将它转成一个int数组或List再进行后续处理。 实现可用Array.ConvertAll&lt;/&gt; 泛型方法来实现1234string str = &quot;56,657,0,1,2,3,4,5,6,7,8&quot;;int[] arrInt = Array.ConvertAll&lt;string, int&gt;(str.Split(&apos;,&apos;), s =&gt; int.Parse(s));foreach (int i in arrInt) Console.WriteLine(i); 将这功能做成string的扩展方法12345678910111213public static List&lt;T&gt; ToList&lt;T&gt;(this string str, char split, Converter&lt;string, T&gt; convertHandler)&#123; if (string.IsNullOrEmpty(str)) &#123; return new List&lt;T&gt;(); &#125; else &#123; string[] arr = str.Split(split); T[] Tarr = Array.ConvertAll(arr, convertHandler); return new List&lt;T&gt;(Tarr); &#125;&#125; 调用方法：1List&lt;int&gt; intList = str.ToList&lt;int&gt;(&apos;,&apos;, s =&gt; int.Parse(s));]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C#小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Powerdesigner与数据库同步]]></title>
    <url>%2F2018%2F01%2F30%2FPowerdesigner%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[概述在使用PowerDesigner进行数据库设计、生成数据库，并开发进行一段时间后， 在这段时间内，数据库的结构必然会有一些变化。我们往往会遇到这样的问题，PowerDesigner与现有数据库结构不匹配。如果人工的比较，即费时又会出错。 PowerDesigner 生成数据库由于人工比较的缺陷，我们需要一个工具来解决。首先，因为PowerDesigner文件与数据库文件是完全不同的两种文件格式，所以我们先要将它们转换成同样的数据结构。我们用PowerDesigner的物理模型生成一个新的数据库。以生成SQL SERVER 为例： “Database”-&gt;”Generate Database” 此时数据库设计为Employee表（原始数据库结构）： 然后，在输出目录你会看到SQL脚本文件，新建一个数据库，并执行脚本现在我们改变一些设计，表结构如下（新数据库结构）： 将EmpName的数据类型改为nvarchar(100)， 添加DeptID列。 数据库架构比较工具数据库数据对比工具 SQLDiff（MSSQL版）是针对MS SQLServer的一款小工具，可以针对两个数据进行表结构和数据的对比。 1、结构对比：如开发库和正式库之间的结构和数据同步，此工具可以告诉您哪个表结构有字段的增加减少，或者字段类型的改变，并生成sql进行结构的同步。2、数据对比：如对比两个数据库中的某个表的数据差异，有差异的行会用颜色进行标记，可生成sql脚本进行两个库的同步。下载链接：http://download.csdn.net/download/swordmanli/9629605]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Powerdesigner,工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageOffice_4.2.0.1_ASP.NET MVC开发笔记]]></title>
    <url>%2F2018%2F01%2F30%2FPageOffice-4-2-0-1-ASP-NET-MVC%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[PageOffice开发笔记开发环境：vs2015，mvc，razor使用操作1. 双击运行Setup.exe安装服务器组件。2. 第一次运行包含PageOfficeLink组件的网页时，会弹出注册对话框，请输入注册信息注册。3. 如果新建网站或集成PageOffice到您现有的网站里:拷贝“集成文件”目录下的“pageoffice”文件夹到您自己网站的根目录下； 页面操作前台：1234567891011121314@&#123; ViewBag.Title = &quot;Word&quot;;&#125;&lt;script type=&quot;text/javascript&quot;&gt; function Save() &#123; document.getElementById(&quot;PageOfficeCtrl1&quot;).WebSave(); &#125; &lt;/script&gt;&lt;div style=&quot;width:900px; height:600px;&quot;&gt; @Html.Raw(ViewBag.EditorHtml)&lt;/div&gt; 控制器12345678910111213141516171819202122232425262728293031namespace PageOffice4_MVC_Razor.Controllers&#123; public class WordController : Controller &#123; public void SaveDoc() &#123; ViewBag.Message = &quot;Your app description page.&quot;; string filePath = Server.MapPath(&quot;/test.doc&quot;); PageOffice.FileSaver fs = new PageOffice.FileSaver(); fs.SaveToFile(filePath); fs.Close(); &#125; public ActionResult Word() &#123; ViewBag.Message = &quot;Your contact page.&quot;; PageOffice.PageOfficeCtrl pc = new PageOffice.PageOfficeCtrl(); pc.AddCustomToolButton(&quot;保存&quot;, &quot;Save()&quot;, 1); pc.SaveFilePage = &quot;/Word/SaveDoc&quot;; pc.ServerPage = &quot;/pageoffice/server.aspx&quot;; pc.WebOpen(&quot;/test.doc&quot;, PageOffice.OpenModeType.docAdmin, &quot;s&quot;); ViewBag.EditorHtml = pc.GetHtmlCode(&quot;PageOfficeCtrl1&quot;); return View(); &#125; &#125;&#125; 帮助文档链接：http://www.zhuozhengsoft.com/Technical/]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>MVC,PageOffice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvc4.5从客户端中检测到有潜在危险的 Request.Form 值]]></title>
    <url>%2F2018%2F01%2F29%2Fmvc4-5%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E6%A3%80%E6%B5%8B%E5%88%B0%E6%9C%89%E6%BD%9C%E5%9C%A8%E5%8D%B1%E9%99%A9%E7%9A%84-Request-Form-%E5%80%BC%2F</url>
    <content type="text"><![CDATA[错误截图：今天，在做一个mvc表单提交，其中内容框使用UEditor插件，支持带html文本内容，结果在提交的时候遇到如下提示： 解决方法： webconfig修改： 123&lt;system.web&gt; &lt;httpRuntime targetFramework=&quot;4.5&quot; requestValidationMode=&quot;2.0&quot;/&gt;&lt;/system.web&gt; 请求控制器修改： 123456[ValidateInput(false)][HttpPost] public ActionResult Form(VideoMDL model) &#123; return Json(&quot;OK&quot;, JsonRequestBehavior.AllowGet); &#125; [ValidateInput(false)] 不启用验证（默认为True） 其他Server.HtmlEncode(content)转码，过滤一些字符。]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 常用的快捷键]]></title>
    <url>%2F2018%2F01%2F28%2FSublime-Text-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 快捷键（实用，快速换行等）1.选择类Ctrl+D ：选中光标所占的文本，继续操作则会选中下一个相同的文本。Alt+F3：选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L：选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L ：先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M：选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M：光标移动至括号内结束或开始的位置。Ctrl+Enter：在下一行插入新行。举个例子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter： 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ ：选中代码，按下快捷键，折叠代码。Ctrl+Shift+] ：选中代码，按下快捷键，展开代码。Ctrl+K+0 ：展开所有折叠代码。Ctrl+← ：向左单位性地移动光标，快速移动光标。Ctrl+→ ：向右单位性地移动光标，快速移动光标。shift+↑ ：向上选中多行。shift+↓ ：向下选中多行。Shift+← ：向左选中文本。Shift+→： 向右选中文本。Ctrl+Shift+←：向左单位性地选中文本。Ctrl+Shift+→：向右单位性地选中文本。Ctrl+Shift+↑：将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓：将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑：向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓：向下添加多行光标，可同时编辑多行。 搜索类Ctrl+J：合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D：复制光标所在整行，插入到下一行。Tab：向右缩进。Shift+Tab：向左缩进。Ctrl+K+K：从光标处开始删除代码至行尾。Ctrl+Shift+K：删除整行。Ctrl+/：注释单行。Ctrl+Shift+/ ：注释多行。Ctrl+K+U：转换大写。Ctrl+K+L：转换小写。Ctrl+Z：撤销。Ctrl+Y：恢复撤销。Ctrl+U：软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2：设置书签Ctrl+T：左右字母互换。F6： 单词检测拼写 显示类Ctrl+Tab：按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown：向左切换当前窗口的标签页。Ctrl+PageUp： 向右切换当前窗口的标签页。Alt+Shift+1： 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2： 左右分屏-2列Alt+Shift+3： 左右分屏-3列Alt+Shift+4： 左右分屏-4列Alt+Shift+5： 等分4屏Alt+Shift+8： 垂直分屏-2屏Alt+Shift+9： 垂直分屏-3屏Ctrl+K+B： 开启/关闭侧边栏。F11： 全屏模式Shift+F11：免打扰模式 图解1.选择一个选中项的下一个匹配项: ctrl+d把光标放在一个单词上，按下⌘+ D,将选择这个单词。一直按住⌘且按D多次，将选择当前选中项的下一个匹配项。通过按住⌘,再按D三次,将选择三个相同的文本。 2.选择一个选中项的所有匹配项: alt+f3和上面一样,但它选择文件中的所有匹配项。小心使用这个,因为它能选择一个文件中的所有匹配项. . 3.选择与光标关联的开始和结束标签: ctrl+shift+’这是一个法宝。也许你希望所有属性保持不变,但只是想选择标签。这个快捷键为你这样做,会注意到你可以在一次操作多个标签。需要Emmet插件 4.选择容器内内容: ctrl+shift+a如果你把光标放在文本间再按下上面的键将选择文本,就像ctrl+ D。但是再次按下它，将选择父容器,再按,将选择父容器的父容器。需要Emmet插件 5.选择括号内的内容: ctrl+shift+m这有助于选择括号之间的一切。同样适用于CSS。 6.上移或下移行: ctrl+shift+↑ 或 ↓ 7.复制行或选中项: ctrl+shift+d如果你已经选中了文本,它会复制你的选中项。否则,把光标放在行上,会复制整行。 8.增加和减少缩进: ctrl+[ 或 ] 9.剪切行或选中项: ctrl+x 10.粘贴并保持缩进: ctrl+shift+v这是又一个我每次都用的快捷键。在gif中我显示了普通粘贴(ctrl+ V)和缩进粘贴两种效果的对比。注意缩进如何排列。 11.用标签包裹行或选中项: alt+shift+w使用标签包裹一行; 开始输入你想使用的标签,你成功了. 12.移除未闭合的容器元素: ctrl+shift+;这会移除与你的光标相关的父标签。对清除标记很有帮助。 13.计算数学表达式: ctrl+shift+y我从未想过我会经常使用这个，但是确实很好用 14.递增和递减: alt+shift+↑ 或 ↓，ctrl+ ↑ 或 ↓按住 ↑ 将以10的步长改变数字, 不按住以1为步长. 同时注意到你不需要选择数字, Sublime Text 足够聪明到更新本行最近的数字. 15.大写和小写: ctrl+k+u,ctrl+k+l 16.注释选中项/行: ctrl+/这个在所有语言下都可用, 对行和选中项都可用.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC使用x.PagedList分页]]></title>
    <url>%2F2018%2F01%2F28%2FMVC%E4%BD%BF%E7%94%A8x-PagedList%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[MVC分页 Nuget安装 X.PagedList和X.PagedList.MVCpackage.config文件: 12&lt;package id=&quot;X.PagedList&quot; version=&quot;1.24.1.300&quot; targetFramework=&quot;net45&quot; /&gt;&lt;package id=&quot;X.PagedList.Mvc&quot; version=&quot;4.9.1.310&quot; targetFramework=&quot;net45&quot; /&gt; View界面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@model PagedList.IPagedList&lt;T&gt;@using Model@using PagedList@using PagedList.Mvc&lt;div style=&quot;text-align: center;&quot;&gt; &lt;h1&gt;Mvc分页例子&lt;/h1&gt; &lt;table id=&quot;tbList&quot;&gt; &lt;tbody&gt; @if (Model.Count() != 0) &#123; &lt;tr&gt; &lt;th style=&quot;width: 60px;&quot;&gt;编号&lt;/th&gt; &lt;th style=&quot;width: 150px;&quot;&gt;创建时间&lt;/th&gt; &lt;th style=&quot;width: 200px;&quot;&gt;标题&lt;/th&gt; &lt;th style=&quot;width: 250px;&quot;&gt;内容&lt;/th&gt; &lt;th style=&quot;width: 80px;&quot;&gt;查看次数&lt;/th&gt; &lt;th style=&quot;width: 180px;&quot;&gt;图片&lt;/th&gt; &lt;/tr&gt; foreach (var a in Model) &#123; &lt;tr style=&quot;text-align: center;&quot;&gt; &lt;td&gt;@a.id&lt;/td&gt; &lt;td&gt;@a.createtime&lt;/td&gt; &lt;td&gt;@a.title&lt;/td&gt; &lt;td&gt;@a.body&lt;/td&gt; &lt;td&gt;@a.visitnum&lt;/td&gt; &lt;td&gt;@a.img&lt;/td&gt; &lt;/tr&gt; &#125; &lt;tr&gt; &lt;td colspan=&quot;6&quot;&gt; &lt;div class=&quot;pager&quot;&gt; @if (Model != null) &#123; &lt;span style=&quot;height: 20px; line-height: 20px;&quot;&gt; 共 @Model.TotalItemCount.ToString() 条记录， 当前第 @ViewData[&quot;page&quot;] 页/共 @Model.PageCount 页 &lt;/span&gt; @Html.PagedListPager(Model, page =&gt; Url.Action(&quot;TableByChaJ&quot;, new &#123; page &#125;), new PagedListRenderOptions() &#123; LinkToFirstPageFormat = &quot;首页&quot;, LinkToNextPageFormat = &quot;下一页&quot;, LinkToPreviousPageFormat = &quot;上一页&quot;, LinkToLastPageFormat = &quot;末页&quot;, DisplayItemSliceAndTotal = false, MaximumPageNumbersToDisplay = 3 &#125;) &#125; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 注意：PagedList.IPagedList 中T 改成自己分页的实体类 controller控制器:12345678public ActionResult ActionName(int? page)&#123; int PageNumber = page ?? 1;//page为null时默认值为1 int PageSize = 5; ViewData[&quot;page&quot;] = PageNumber; return View(VideoDAL.GetListPage().ToPagedList(PageNumber, PageSize));&#125; 注意:代码中的list为list 形式，返回视图IPagedList]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>MVC,X.PagedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学使用 Disqus]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%A7%91%E5%AD%A6%E4%BD%BF%E7%94%A8-Disqus%2F</url>
    <content type="text"><![CDATA[科学使用 Disqus详见： http://blog.fooleap.org/use-disqus-correctly.html]]></content>
      <categories>
        <category>Disqus</category>
      </categories>
      <tags>
        <tag>Disqus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dapper使用]]></title>
    <url>%2F2018%2F01%2F23%2Fdapper%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本使用1.连接语句var conn = new SqlConnection(ConfigurationManager.ConnectionStrings[“SqlDiagnosticsDb”].ConnectionString);使用dapper不需要考虑conn是否连接，在执行dapper时自行判断open状态，如果没有打开它会自己打开. 2.insertstring query = “INSERT INTO Book(Name)VALUES(@name)”;conn.Execute(query, book); book类中有name属性，就可以这样方便去写，当然也可以写成 string query = “INSERT INTO Book(Name)VALUES(@name)”;conn.Execute(query, new{@name=book.name}); 3.updatestring query = “UPDATE Book SET Name=@name WHERE id =@id”;conn.Execute(query, book); 4.deletestring query = “DELETE FROM Book WHERE id = @id”;conn.Execute(query, book);conn.Execute(query, new { id = id }); 5.querystring query = “SELECT * FROM Book”;//无参数查询，返回列表，带参数查询和之前的参数赋值法相同.conn.Query(query).ToList(); //返回单条信息string query = “SELECT * FROM Book WHERE id = @id”;book = conn.Query(query, new { id = id }).SingleOrDefault(); 6.传统sql in (1,2,3) 用dapper就这样写conn.Query(“SELECT * FROM Users s WHERE s.id IN (@ids) “,new { ids = new int[]{1,2,3}}) conn.Query(“SELECT * FROM Users s WHERE s.id IN (@ids) “,new { ids = IDs.ToArray()})在dapper因为安全性，不能直接用sql接接，要采用参数化 7.批量插入conn.Execute(@”insert MyTable(colA, colB) values (@a, @b)”, new[] { new { a=1, b=1 }, new { a=2, b=2 }, new { a=3, b=3 } }) 也可以直接写入一个集合conn.Execute(“insert user(name) values(@name)”,users) 这里users是一个user表的对象集合，可一次把集合中的所有数据插入到数据表中. 8.多表查询//查询图书时，同时查找对应的书评，并存在List中。实现1–n的查询操作string query = “SELECT * FROM Book b LEFT JOIN BookReview br ON br.BookId = b.Id WHERE b.id = @id”;Book lookup = null;//Query var b = conn.Query(query, (book, bookReview) =&gt; { //扫描第一条记录，判断非空和非重复 if (lookup == null || lookup.Id != book.Id) lookup = book; //书对应的书评非空，加入当前书的书评List中，最后把重复的书去掉。 if (bookReview != null) lookup.Reviews.Add(bookReview); return lookup; }, new { id = id }).Distinct().SingleOrDefault();return b; 多表联合查询是比较麻烦一些，到现在不是完全明白，多看几个例子var sql = @”select * from Posts p join Users u on u.Id = p.OwnerId Order by p.Id”;var data = conn.Query(sql, (post, user) =&gt; { post.Owner = user; return post;}，splitOn：”id”); Post类和User类,它们存在外键， conn.Query返回的类型是最后一个参数Post, 其中Post中有一属性Owner是User对象，在(post, user)=&gt;lamda中指定了Owner值，上边的代码中的splitOn是ID，运行时，会从查询结果所有字段列表的最后一个字段开始进行匹配，一直到找到Id这个字段（大小写忽略），找到的第一个ID字段匹配User类的ID属性，那么从ID到最后一个字段都属于User，ID以前的字段都被影射到Post， 通过 (post, user) =&gt; { return post;},把两个类的实例解析出来。 9.三表查询，一个是关联主键表（单个对象），一个是关联外键表（集合）。1234567891011121314151617181920212223242526272829303132333435363738394041424344public partial class UserInfo &#123; public UserInfo() &#123; this.Persion = new HashSet&lt;Persion&gt;(); this.MyTYC = new HashSet&lt;MyTYC&gt;(); &#125; public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; public Nullable&lt;System.DateTime&gt; createTime &#123; get; set; &#125; public Movies Movies &#123; get; set; &#125; public virtual ICollection&lt;MyTYC&gt; MyTYC &#123; get; set; &#125; &#125; public class Movies &#123; public int ID &#123; get; set; &#125; public string Title &#123; get; set; &#125; public string ReleaseDate &#123; get; set; &#125; public string Genre &#123; get; set; &#125; public string Price &#123; get; set; &#125; public UserInfo UserInfo &#123; get; set; &#125; &#125; public partial class MyTYC &#123; public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; &#125; string sql = @&quot;select * from UserInfo u inner join [Movies].dbo.Movies m on u.id=m.ID inner join MyTYC t on u.id=t.id&quot;; var data = conn.Query&lt;UserInfo, Movies, MyTYC, UserInfo&gt;(sql, (u, m, t) =&gt; &#123; u.Movies = m; u.MyTYC.Add(t); return u; &#125;); 注意这里的对象和集合的获取方法：u.Movies = m; u.MyTYC.Add(t); 10.多结果查询1234567891011 var sql = @&quot;select * from Customers where CustomerId = @id; select * from Orders where CustomerId = @id; select * from Returns where CustomerId = @id&quot;; using (var multi = connection.QueryMultiple(sql, new &#123;id=selectedId&#125;)) &#123; var customer = multi.Read&lt;Customer&gt;().Single(); var orders = multi.Read&lt;Order&gt;().ToList(); var returns = multi.Read&lt;Return&gt;().ToList(); &#125; 再来一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Program &#123; //创建连接对象 protected static SqlConnection GetConnection() &#123; var connection = new SqlConnection(&quot;Data Source=.;Initial Catalog=TestDB;Integrated Security=True&quot;); connection.Open(); return connection; &#125; static void Main(string[] args) &#123; //测试输出多个结果集 var sql = @&quot;INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;A1&apos;); select @@IDENTITY as A; INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;B1&apos;); select @@IDENTITY as A; INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;C1&apos;); select @@IDENTITY as A&quot;; //初始化数据库连接 using (SqlConnection connection = GetConnection()) &#123; List&lt;int&gt; ilist = new List&lt;int&gt;(); //执行查询，获取结果集集合 var multi = connection.QueryMultiple(sql); //遍历结果集 while(!multi.IsConsumed) &#123; //读取当前结果集 var result = multi.Read().ToList()[0].A; if (result != null) &#123; ilist.Add(Convert.ToInt32(result)); &#125; &#125; //for(int i = 0;i&lt;3;i++) //&#123; // var result = multi.Read().ToList()[0].A; // if (result != null) // &#123; // ilist.Add(Convert.ToInt32(result)); // &#125; //&#125; foreach (var item in ilist) &#123; Console.WriteLine(item.ToString()); &#125; &#125; Console.ReadLine(); &#125; &#125; 11.支持存储过程USE [Datamip]GO/** Object: StoredProcedure [dbo].[sp_GetUsers] Script Date: 09/02/2016 09:14:04 **/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCreate proc [dbo].[sp_GetUsers] @id intasbeginselect * from Users where UserID = @id ;end 在这里，我们需要向存储过程塞入一个@id参数，返回具体的Users EntityList，好了，下面再看一下Query如何构造。 static void Main(string[] args){ var connection = new SqlConnection(“Data Source=.;Initial Catalog=Datamip;Integrated Security=True;MultipleActiveResultSets=True”); var info = connection.Query(“sp_GetUsers”, new { id = 5 }, commandType: CommandType.StoredProcedure);} 12.如果某一代码中多次操作数据库，可以把conn设置为打开，最后时再close.conn.open()conn.Query(…..…..for….…..conn.close()]]></content>
      <categories>
        <category>ORM</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用.NET 反射机制(Reflecttion)读取和保存Xml配置文档]]></title>
    <url>%2F2018%2F01%2F23%2F%E4%BD%BF%E7%94%A8-NET-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-Reflecttion-%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98Xml%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[原文链接： 定义个一个接口：undefined 将其编译成DLL文件，供其他程序引用。 插件必须编译成DLL文件，可包含多个类，类可以是窗体类型，也可以是控制台类型的。类必须实现上面的接口。 主程序负责显示插件信息，并运行插件。 主程序会生成XML格式的配置文件，使下次访问加快。 下载：http://download.csdn.net/download/rightmin/810378]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dapper的增、删、查改的CodeSmith模板]]></title>
    <url>%2F2018%2F01%2F23%2Fdapper%E7%9A%84%E5%A2%9E%E3%80%81%E5%88%A0%E3%80%81%E6%9F%A5%E6%94%B9%E7%9A%84CodeSmith%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[CodeSmith模板访问量不大的项目我都是用EF写数据库操作，因为EF除了速度上慢以外，但开发效率极快，省略了很多sql写法，并能很方便的调用外键、集合等信息，用EF写项目最爽的事。不过有些项目网站要考虑运行速度，这时不得不用其它的ORM框架，我常用dapper，因为它效果快，而且写sql非常灵活. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;%@ Template Language=&quot;C#&quot; TargetLanguage=&quot;Text&quot; %&gt;&lt;%@ Property Name=&quot;BaseNamespace&quot; Type=&quot;String&quot; %&gt;&lt;%@ Property Name=&quot;SourceDatabase&quot; Type=&quot;SchemaExplorer.DatabaseSchema&quot; Category=&quot;Context&quot; Description=&quot;Database that the documentation should be based on.&quot; %&gt;&lt;%-- 要打印的表 --%&gt;&lt;%@ Property Name=&quot;Table&quot; Type=&quot;TableSchema&quot; DeepLoad=&quot;True&quot; Optional=&quot;False&quot; Category=&quot;Context&quot; Description=&quot;&quot; %&gt; &lt;%@ Assembly Name=&quot;SchemaExplorer&quot; %&gt;&lt;%@ Assembly Name=&quot;System.Design&quot; %&gt;&lt;%@ Import Namespace=&quot;SchemaExplorer&quot; %&gt; using System;using System.Collections.Generic;using System.linq;using System.Text;using &lt;%=BaseNamespace%&gt;.Model;using Dapper;using MayHuan.Data;using System.Collections; namespace &lt;%=BaseNamespace%&gt;.Services&#123; public class &lt;%= Table.Name%&gt;Service:I&lt;%= Table.Name%&gt; &#123; public bool Delete(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;Delete from &lt;%= Table.Name%&gt; where OID=@OID&quot;, new &#123; OID = model.OID &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public bool Insert(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;INSERT INTO &lt;%= Table.Name%&gt; &lt;% System.Text.StringBuilder sbSql=new System.Text.StringBuilder(); %&gt; &lt;% foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(col.Name+&quot;,&quot;); &#125; &#125; %&gt; (&lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt;) VALUES &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(&quot;@&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; (&lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt;)&quot;, &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.Append(col.Name+&quot; = model.&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; new &#123; &lt;%=sbSql.ToString().Trim(&apos;,&apos;) %&gt; &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public bool Update(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;UPDATE &lt;%= Table.Name%&gt; SET &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(col.Name+&quot;=@&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; &lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt; WHERE OID=@OID&quot;, &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.Append(col.Name+&quot; = model.&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; new &#123; &lt;%=sbSql.ToString().Trim(&apos;,&apos;) %&gt;,OID = model.OID &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public M&lt;%= Table.Name%&gt; GetModelByID(int id) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Query&lt;M&lt;%= Table.Name%&gt;&gt;(@&quot;select * from &lt;%= Table.Name%&gt; where OID=@OID&quot;, new &#123; OID =id &#125;).FirstOrDefault(); conn.Close(); return a; &#125; &#125; public Model.PageDataView&lt;M&lt;%= Table.Name%&gt;&gt; GetList(string companyName, int pageNum, int pageSize = 10) &#123; var criteria = new PageCriteria(); criteria.CurrentPage = pageNum; criteria.Fields = &quot;a.*&quot;; criteria.PageSize = pageSize; criteria.PrimaryKey = &quot;a.OID&quot;; criteria.TableName = @&quot;&lt;%= Table.Name%&gt; a&quot;; string sqlFilter = &quot;1=1&quot;; if (!string.IsNullOrEmpty(companyName)) sqlFilter += string.Format(&quot; and b.CompanyName like &apos;%&#123;0&#125;%&apos;&quot;, companyName); criteria.Condition += sqlFilter; var r = DBCommon.GetPageData&lt;M&lt;%= Table.Name%&gt;&gt;(criteria); return r; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ORM</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net 用支付宝沙箱环境测试支付接口]]></title>
    <url>%2F2018%2F01%2F21%2Fasp-net-%E7%94%A8%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[沙箱环境的配置1.注册成为开发人员注册成功以后，点击以下链接，进入到支付宝官方的沙箱环境说明：https://docs.open.alipay.com/200/10531 2.沙箱介绍然后点击上图中的沙箱环境，跳转到自己的沙箱环境，配置自己的沙箱环境 。 ## 3.秘钥 至于公钥秘钥的生成，点击 https://docs.open.alipay.com/291/105971 下载生成RSA密钥的工具，操作视频可以搜索该链接：https://openclub.alipay.com/index.php?c=video&amp;fid=76 查看生成秘钥的具体操作步骤。重点是秘钥长度一定要是2048，一定要是2048.当时我测试的时候，生成的1024的，验签通过，但是一上传就提示失败。可见再牛逼的网站也是有bug的。 4.下载支付宝支付demo 打开demo，把配置里面的配置改成自己沙箱账号的配置。支付宝支付demo下载的链接：https://docs.open.alipay.com/54/106682/把配置文件里面的配置改成沙箱 5.下载沙箱钱包进行支付测试，注意不是支付宝哦，详细查看文说明档。，目前沙箱钱包仅提供Android版本，可点击 下载]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端静态文件如何应对HTTPS的到来]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%89%8D%E7%AB%AF%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9HTTPS%E7%9A%84%E5%88%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[原文链接：https://www.cnblogs.com/webARM/p/5728695.html var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/18/前端静态文件如何应对HTTPS的到来', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建评论系统]]></title>
    <url>%2F2018%2F01%2F18%2F%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[基础使用Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 1. 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net ）。 你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。 2. 引入 Gitment将下面的代码添加到你的页面：123456789101112131415&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: &apos;页面 ID&apos;, // 可选。默认为 location.href owner: &apos;你的 GitHub ID&apos;, repo: &apos;存储评论的 repo&apos;, oauth: &#123; client_id: &apos;你的 client ID&apos;, client_secret: &apos;你的 client secret&apos;, &#125;,&#125;)gitment.render(&apos;container&apos;)&lt;/script&gt; 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。 如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。$ npm install –save gitment 3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。 之后其他用户即可在该页面发表评论。 自定义Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能） 比如你可以通过自定义主题将评论框放在评论列表前面：1234567891011121314151617const myTheme = &#123; render(state, instance) &#123; const container = document.createElement(&apos;div&apos;) container.lang = &quot;en-US&quot; container.className = &apos;gitment-container gitment-root-container&apos; container.appendChild(instance.renderHeader(state, instance)) container.appendChild(instance.renderEditor(state, instance)) container.appendChild(instance.renderComments(state, instance)) container.appendChild(instance.renderFooter(state, instance)) return container &#125;,&#125;const gitment = new Gitment(&#123; // ... theme: myTheme,&#125;)gitment.render(&apos;container&apos;) 原文链接：https://imsun.net/posts/gitment-introduction/ var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/18/搭建评论系统', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>GitHub Issues</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探-Hexo]]></title>
    <url>%2F2018%2F01%2F16%2F%E5%88%9D%E6%8E%A2-Hexo%2F</url>
    <content type="text"><![CDATA[使用Hexo+Github一步步搭建属于自己的博客 相关步骤：1.安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面输入npm install hexo -g，开始安装Hexo输入hexo -v，检查hexo是否安装成功输入hexo init，初始化该文件夹（有点漫长的等待。。。）看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件输入hexo g，首次体验Hexo输入hexo s，开启服务器，访问该网址，正式体验Hexo问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent登录Github，点击头像下的settings，添加ssh新建一个new ssh key，将id_rsa.pub文件里的内容复制上去输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com” 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名”这时候在文件夹_posts目录下将会看到已经创建的文件在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章到此为止，最基本的也是最全面的hexo+github搭建博客完结。 原文引自：http://www.cnblogs.com/fengxiongZz/p/7707219.html其他参考：https://segmentfault.com/a/1190000009544924其他参考：http://blog.csdn.net/u010053344/article/details/50701191NexT配置：http://theme-next.iissnan.com/ var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/16/初探-Hexo', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 高级配置]]></title>
    <url>%2F2018%2F01%2F16%2FHexo-%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Site 网站title: 为学 网站标题subtitle: 天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。 #网站副标题description: 天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。 #网站描述author: willxue #您的名字language: zh-CN #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区 URL 网址url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults: Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/16/Hexo-高级配置', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
