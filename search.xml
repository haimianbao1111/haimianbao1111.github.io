<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dapper使用]]></title>
    <url>%2F2018%2F01%2F23%2Fdapper%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本使用 连接语句12345var conn = new SqlConnection( ConfigurationManager.ConnectionStrings[&quot;SqlDiagnosticsDb&quot;].ConnectionString); ``` 使用dapper不需要考虑conn是否连接，在执行dapper时自行判断open状态，如果没有打开它会自己打开。 2. insert string query = “INSERT INTO Book(Name)VALUES(@name)”;conn.Execute(query, book);12book类中有name属性，就可以这样方便去写，当然也可以写成 string query = “INSERT INTO Book(Name)VALUES(@name)”;conn.Execute(query, new{@name=book.name});123. update string query = “UPDATE Book SET Name=@name WHERE id =@id”;conn.Execute(query, book);124. delete string query = “DELETE FROM Book WHERE id = @id”;conn.Execute(query, book);conn.Execute(query, new { id = id });125. query string query = “SELECT * FROM Book”;//无参数查询，返回列表，带参数查询和之前的参数赋值法相同。conn.Query(query).ToList(); //返回单条信息string query = “SELECT * FROM Book WHERE id = @id”;book = conn.Query(query, new { id = id }).SingleOrDefault();126. 传统sql in (1,2,3) 用dapper就这样写 conn.Query(“SELECT * FROM Users s WHERE s.id IN (@ids) “,new { ids = new int[]{1,2,3}}) conn.Query(“SELECT * FROM Users s WHERE s.id IN (@ids) “,new { ids = IDs.ToArray()})1234在dapper因为安全性，不能直接用sql接接，要采用参数化7. 批量插入 conn.Execute(@”insert MyTable(colA, colB) values (@a, @b)”, new[] { new { a=1, b=1 }, new { a=2, b=2 }, new { a=3, b=3 } })12也可以直接写入一个集合 conn.Execute(“insert user(name) values(@name)”,users)123这里users是一个user表的对象集合，可一次把集合中的所有数据插入到数据表中.8. 多表查询 //查询图书时，同时查找对应的书评，并存在List中。实现1–n的查询操作string query = “SELECT * FROM Book b LEFT JOIN BookReview br ON br.BookId = b.Id WHERE b.id = @id”;Book lookup = null;//Query var b = conn.Query(query, (book, bookReview) =&gt; { //扫描第一条记录，判断非空和非重复 if (lookup == null || lookup.Id != book.Id) lookup = book; //书对应的书评非空，加入当前书的书评List中，最后把重复的书去掉。 if (bookReview != null) lookup.Reviews.Add(bookReview); return lookup; }, new { id = id }).Distinct().SingleOrDefault();return b; 12多表联合查询是比较麻烦一些，到现在不是完全明白，多看几个例子 var sql = @”select * from Posts p join Users u on u.Id = p.OwnerId Order by p.Id”;var data = conn.Query(sql, (post, user) =&gt; { post.Owner = user; return post;}，splitOn：”id”);1234Post类和User类,它们存在外键， conn.Query返回的类型是最后一个参数Post, 其中Post中有一属性Owner是User对象，在(post, user)=&gt;lamda中指定了Owner值，上边的代码中的splitOn是ID，运行时，会从查询结果所有字段列表的最后一个字段开始进行匹配，一直到找到Id这个字段（大小写忽略），找到的第一个ID字段匹配User类的ID属性，那么从ID到最后一个字段都属于User，ID以前的字段都被影射到Post， 通过 (post, user) =&gt; &#123; return post;&#125;,把两个类的实例解析出来。9. 三表查询，一个是关联主键表（单个对象），一个是关联外键表（集合）。 public partial class UserInfo{ public UserInfo() { this.Persion = new HashSet(); this.MyTYC = new HashSet(); } public int id { get; set; } public string name { get; set; } public Nullable&lt;System.DateTime&gt; createTime { get; set; } public Movies Movies { get; set; } public virtual ICollection&lt;MyTYC&gt; MyTYC { get; set; } }12 public class Movies{ public int ID { get; set; } public string Title { get; set; } public string ReleaseDate { get; set; } public string Genre { get; set; } public string Price { get; set; } public UserInfo UserInfo { get; set; }}12 public partial class MyTYC{ public int id { get; set; } public string name { get; set; }}12 string sql = @”select * from UserInfo uinner join [Movies].dbo.Movies m on u.id=m.IDinner join MyTYC t on u.id=t.id”; var data = conn.Query(sql, (u, m, t) =&gt; { u.Movies = m; u.MyTYC.Add(t); return u; });1234注意这里的对象和集合的获取方法：u.Movies = m; u.MyTYC.Add(t); 10. 多结果查询 var sql = @”select from Customers where CustomerId = @id; select from Orders where CustomerId = @id; select * from Returns where CustomerId = @id”; using (var multi = connection.QueryMultiple(sql, new {id=selectedId})) { var customer = multi.Read().Single(); var orders = multi.Read().ToList(); var returns = multi.Read().ToList(); } 12再来一个 class Program { //创建连接对象 protected static SqlConnection GetConnection() { var connection = new SqlConnection(&quot;Data Source=.;Initial Catalog=TestDB;Integrated Security=True&quot;); connection.Open(); return connection; } static void Main(string[] args) { //测试输出多个结果集 var sql = @&quot;INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;A1&apos;); select @@IDENTITY as A; INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;B1&apos;); select @@IDENTITY as A; INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;C1&apos;); select @@IDENTITY as A&quot;; //初始化数据库连接 using (SqlConnection connection = GetConnection()) { List&lt;int&gt; ilist = new List&lt;int&gt;(); //执行查询，获取结果集集合 var multi = connection.QueryMultiple(sql); //遍历结果集 while(!multi.IsConsumed) { //读取当前结果集 var result = multi.Read().ToList()[0].A; if (result != null) { ilist.Add(Convert.ToInt32(result)); } } //for(int i = 0;i&lt;3;i++) //{ // var result = multi.Read().ToList()[0].A; // if (result != null) // { // ilist.Add(Convert.ToInt32(result)); // } //} foreach (var item in ilist) { Console.WriteLine(item.ToString()); } } Console.ReadLine(); } } 12 11. 支持存储过程 USE [Datamip]GO/** Object: StoredProcedure [dbo].[sp_GetUsers] Script Date: 09/02/2016 09:14:04 **/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCreate proc [dbo].[sp_GetUsers] @id intasbeginselect * from Users where UserID = @id ;end 1在这里，我们需要向存储过程塞入一个@id参数，返回具体的Users EntityList，好了，下面再看一下Query如何构造。 static void Main(string[] args){ var connection = new SqlConnection(“Data Source=.;Initial Catalog=Datamip;Integrated Security=True;MultipleActiveResultSets=True”); var info = connection.Query(“sp_GetUsers”, new { id = 5 }, commandType: CommandType.StoredProcedure);} 112. 如果某一代码中多次操作数据库，可以把conn设置为打开，最后时再close. conn.open()conn.Query(…..…..for….…..conn.close()```]]></content>
      <categories>
        <category>ORM</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用.NET 反射机制(Reflecttion)读取和保存Xml配置文档]]></title>
    <url>%2F2018%2F01%2F23%2F%E4%BD%BF%E7%94%A8-NET-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-Reflecttion-%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98Xml%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[原文链接： 定义个一个接口：undefined 将其编译成DLL文件，供其他程序引用。 插件必须编译成DLL文件，可包含多个类，类可以是窗体类型，也可以是控制台类型的。类必须实现上面的接口。 主程序负责显示插件信息，并运行插件。 主程序会生成XML格式的配置文件，使下次访问加快。 下载：http://download.csdn.net/download/rightmin/810378]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dapper的增、删、查改的CodeSmith模板]]></title>
    <url>%2F2018%2F01%2F23%2Fdapper%E7%9A%84%E5%A2%9E%E3%80%81%E5%88%A0%E3%80%81%E6%9F%A5%E6%94%B9%E7%9A%84CodeSmith%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[CodeSmith模板访问量不大的项目我都是用EF写数据库操作，因为EF除了速度上慢以外，但开发效率极快，省略了很多sql写法，并能很方便的调用外键、集合等信息，用EF写项目最爽的事。不过有些项目网站要考虑运行速度，这时不得不用其它的ORM框架，我常用dapper，因为它效果快，而且写sql非常灵活. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;%@ Template Language=&quot;C#&quot; TargetLanguage=&quot;Text&quot; %&gt;&lt;%@ Property Name=&quot;BaseNamespace&quot; Type=&quot;String&quot; %&gt;&lt;%@ Property Name=&quot;SourceDatabase&quot; Type=&quot;SchemaExplorer.DatabaseSchema&quot; Category=&quot;Context&quot; Description=&quot;Database that the documentation should be based on.&quot; %&gt;&lt;%-- 要打印的表 --%&gt;&lt;%@ Property Name=&quot;Table&quot; Type=&quot;TableSchema&quot; DeepLoad=&quot;True&quot; Optional=&quot;False&quot; Category=&quot;Context&quot; Description=&quot;&quot; %&gt; &lt;%@ Assembly Name=&quot;SchemaExplorer&quot; %&gt;&lt;%@ Assembly Name=&quot;System.Design&quot; %&gt;&lt;%@ Import Namespace=&quot;SchemaExplorer&quot; %&gt; using System;using System.Collections.Generic;using System.linq;using System.Text;using &lt;%=BaseNamespace%&gt;.Model;using Dapper;using MayHuan.Data;using System.Collections; namespace &lt;%=BaseNamespace%&gt;.Services&#123; public class &lt;%= Table.Name%&gt;Service:I&lt;%= Table.Name%&gt; &#123; public bool Delete(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;Delete from &lt;%= Table.Name%&gt; where OID=@OID&quot;, new &#123; OID = model.OID &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public bool Insert(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;INSERT INTO &lt;%= Table.Name%&gt; &lt;% System.Text.StringBuilder sbSql=new System.Text.StringBuilder(); %&gt; &lt;% foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(col.Name+&quot;,&quot;); &#125; &#125; %&gt; (&lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt;) VALUES &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(&quot;@&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; (&lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt;)&quot;, &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.Append(col.Name+&quot; = model.&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; new &#123; &lt;%=sbSql.ToString().Trim(&apos;,&apos;) %&gt; &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public bool Update(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;UPDATE &lt;%= Table.Name%&gt; SET &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(col.Name+&quot;=@&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; &lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt; WHERE OID=@OID&quot;, &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.Append(col.Name+&quot; = model.&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; new &#123; &lt;%=sbSql.ToString().Trim(&apos;,&apos;) %&gt;,OID = model.OID &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public M&lt;%= Table.Name%&gt; GetModelByID(int id) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Query&lt;M&lt;%= Table.Name%&gt;&gt;(@&quot;select * from &lt;%= Table.Name%&gt; where OID=@OID&quot;, new &#123; OID =id &#125;).FirstOrDefault(); conn.Close(); return a; &#125; &#125; public Model.PageDataView&lt;M&lt;%= Table.Name%&gt;&gt; GetList(string companyName, int pageNum, int pageSize = 10) &#123; var criteria = new PageCriteria(); criteria.CurrentPage = pageNum; criteria.Fields = &quot;a.*&quot;; criteria.PageSize = pageSize; criteria.PrimaryKey = &quot;a.OID&quot;; criteria.TableName = @&quot;&lt;%= Table.Name%&gt; a&quot;; string sqlFilter = &quot;1=1&quot;; if (!string.IsNullOrEmpty(companyName)) sqlFilter += string.Format(&quot; and b.CompanyName like &apos;%&#123;0&#125;%&apos;&quot;, companyName); criteria.Condition += sqlFilter; var r = DBCommon.GetPageData&lt;M&lt;%= Table.Name%&gt;&gt;(criteria); return r; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ORM</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[asp.net 用支付宝沙箱环境测试支付接口]]></title>
    <url>%2F2018%2F01%2F21%2Fasp-net-%E7%94%A8%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[沙箱环境的配置 1.注册成为开发人员注册成功以后，点击以下链接，进入到支付宝官方的沙箱环境说明：https://docs.open.alipay.com/200/10531 2.沙箱介绍然后点击上图中的沙箱环境，跳转到自己的沙箱环境，配置自己的沙箱环境 。 # 3.秘钥生成 至于公钥秘钥的生成，点击 https://docs.open.alipay.com/291/105971 下载生成RSA密钥的工具，操作视频可以搜索该链接：https://openclub.alipay.com/index.php?c=video&amp;fid=76 查看生成秘钥的具体操作步骤。重点是秘钥长度一定要是2048，一定要是2048.当时我测试的时候，生成的1024的，验签通过，但是一上传就提示失败。可见再牛逼的网站也是有bug的. 4.下载支付宝支付demo 打开demo，把配置里面的配置改成自己沙箱账号的配置。支付宝支付demo下载的链接：https://docs.open.alipay.com/54/106682/把配置文件里面的配置改成沙箱 5.下载沙箱钱包进行支付测试，注意不是支付宝哦，详细查看文说明档。，目前沙箱钱包仅提供Android版本，可点击 下载]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端静态文件如何应对HTTPS的到来]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%89%8D%E7%AB%AF%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9HTTPS%E7%9A%84%E5%88%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[原文链接：https://www.cnblogs.com/webARM/p/5728695.html var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/18/前端静态文件如何应对HTTPS的到来', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建评论系统]]></title>
    <url>%2F2018%2F01%2F18%2F%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[基础使用1. 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net ）。 你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。 2. 引入 Gitment将下面的代码添加到你的页面：123456789101112131415&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: &apos;页面 ID&apos;, // 可选。默认为 location.href owner: &apos;你的 GitHub ID&apos;, repo: &apos;存储评论的 repo&apos;, oauth: &#123; client_id: &apos;你的 client ID&apos;, client_secret: &apos;你的 client secret&apos;, &#125;,&#125;)gitment.render(&apos;container&apos;)&lt;/script&gt; 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。 如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。$ npm install –save gitment 3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。 之后其他用户即可在该页面发表评论。 自定义Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能） 比如你可以通过自定义主题将评论框放在评论列表前面：1234567891011121314151617const myTheme = &#123; render(state, instance) &#123; const container = document.createElement(&apos;div&apos;) container.lang = &quot;en-US&quot; container.className = &apos;gitment-container gitment-root-container&apos; container.appendChild(instance.renderHeader(state, instance)) container.appendChild(instance.renderEditor(state, instance)) container.appendChild(instance.renderComments(state, instance)) container.appendChild(instance.renderFooter(state, instance)) return container &#125;,&#125;const gitment = new Gitment(&#123; // ... theme: myTheme,&#125;)gitment.render(&apos;container&apos;) 原文链接：https://imsun.net/posts/gitment-introduction/ var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/18/搭建评论系统', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>GitHub Issues</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab之Gitlab-CI体验]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%8D%9A%E5%AE%A2%E8%AF%A6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Gitlab-CI持续集成(CI)：通常使用CI来做一些自动化工作，比如程序的打包，单元测试，部署等，这种构建方式避免了打包环境差异引起的错误，提高了工作效率。GitLab-CI是GitLab官方提供的持续集成服务，我们可以在仓库的根目录下新建.gitlab-ci.yml文件，自己定义持续集成流程模板，并且在GitLab中配置runner，在之后的每次提交合并中将会触发构建，并且可以通过GitLab的hook, 在代码提交的各个环节自动地完成一系列的构建工作，总之对于一些非复杂性的集成需求，都是可以满足的。链接 http://www.mdslq.cn/ var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/17/博客详构', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>博客详构</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探-Hexo]]></title>
    <url>%2F2018%2F01%2F16%2F%E5%88%9D%E6%8E%A2-Hexo%2F</url>
    <content type="text"><![CDATA[什么都没有啊………………… var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/16/初探-Hexo', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>初探-Hexo</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 高级配置]]></title>
    <url>%2F2018%2F01%2F16%2FHexo-%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Site 网站title: 为学 网站标题subtitle: 天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。 #网站副标题description: 天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。 #网站描述author: willxue #您的名字language: zh-CN #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区 URL 网址url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults: Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/16/Hexo-高级配置', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Hexo 高级配置</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
</search>
