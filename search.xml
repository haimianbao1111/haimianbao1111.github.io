<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[获取input(file)的路径，更改默认样式]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%8E%B7%E5%8F%96-input-type-file-%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述:如何获取input(file)的路径？ 定义标签 1&lt;input type=&quot;file&quot; id=&quot;file_input&quot;&gt;&lt;img src=&quot;&quot; class=&quot;img&quot; /&gt; 获取路径 1234567891011$(&quot;input[type=&apos;file&apos;]&quot;).change(function()&#123; var file = this.files[0]; if (window.FileReader) &#123; var reader = new FileReader(); reader.readAsDataURL(file); //监听文件读取结束后事件 reader.onloadend = function (e) &#123; $(&quot;.img&quot;).attr(&quot;src&quot;,e.target.result); //e.target.result就是最后的路径地址 &#125;; &#125; &#125;); input(file)样式修改及上传文件名显示 实现思路：a标签包裹input元素设置a标签为上传按钮的样式，相对定位设置input为透明，绝对定位，覆盖到a上面 html代码：1234&lt;a href=&quot;javascript:;&quot; class=&quot;file gradient&quot;&gt;选择文件 &lt;input type=&quot;file&quot; &gt; &lt;div class=&quot;showFileName&quot;&gt;&lt;/div&gt;&lt;/a&gt; CSS代码：123456789101112131415161718192021222324252627282930313233.file &#123; position: relative; display: inline-block; background: #ccc; border: 1px solid #333; padding: 4px 20px; overflow: hidden; text-decoration: none; text-indent: 0; line-height: 20px; border-radius: 20px; color: #333; font-size: 13px;&#125;.file input &#123; position: absolute; font-size: 100px; right: 0; top: 0; opacity: 0;&#125; .gradient&#123; filter:alpha(opacity=100 finishopacity=50 style=1 startx=0,starty=0,finishx=0,finishy=150) progid:DXImageTransform.Microsoft.gradient(startcolorstr=#fff,endcolorstr=#ccc,gradientType=0); -ms-filter:alpha(opacity=100 finishopacity=50 style=1 startx=0,starty=0,finishx=0,finishy=150) progid:DXImageTransform.Microsoft.gradient(startcolorstr=#fff,endcolorstr=#ccc,gradientType=0);/*IE8*/ background:#ccc; /* 一些不支持背景渐变的浏览器 */ background:-moz-linear-gradient(top, #fff, #ccc); background:-webkit-gradient(linear, 0 0, 0 bottom, from(#fff), to(#ccc)); background:-o-linear-gradient(top, #fff, #ccc); &#125; 上传文件的文件名不显示，需要用js处理:12345678910111213$(&quot;.file&quot;).on(&quot;change&quot;,&quot;input[type=&apos;file&apos;]&quot;,function()&#123; var filePath=$(this).val(); if(filePath.indexOf(&quot;jpg&quot;)!=-1 || filePath.indexOf(&quot;png&quot;)!=-1)&#123; $(&quot;.fileerrorTip1&quot;).html(&quot;&quot;).hide(); var arr=filePath.split(&apos;\\&apos;); var fileName=arr[arr.length-1]; $(&quot;.showFileName1&quot;).html(fileName); &#125;else&#123; $(&quot;.showFileName1&quot;).html(&quot;&quot;); $(&quot;.fileerrorTip1&quot;).html(&quot;您未上传文件，或者您上传文件类型有误！&quot;).show(); return false &#125;&#125;)]]></content>
      <categories>
        <category>Asp.Net Mvc</category>
      </categories>
      <tags>
        <tag>Asp.Net Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET cache缓存的用法]]></title>
    <url>%2F2018%2F03%2F07%2FASP-NET-cache%E7%BC%93%E5%AD%98%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述：HttpRuntime.Cache在ASP.NET的使用 5个等级的缓存 1级是网络级缓存，缓存在浏览器，CDN以及代理服务器中 （举个例子：每个帮助页面都进行了缓存，访问一个页面的代码非常简单）2级是由.net框架 HttpRuntime.Cache完成，在每台服务器的内存中。3级Redis,分布式内存键值存储，在多个支撑同一个站点的服务器上共享缓存项。4级SQL Server Cache，整个数据库，所有数据都被放到内存中。5级SSD。通常只在SQL Server预热后才生效 使用场景： 1.数据可能会被频繁的被使用，这种数据可以缓存。2.数据的访问频率非常高，或者一个数据的访问频率不高，但是它的生存周期很长，这样的数据最好也缓存起来。3.是一个常常被忽略的问题，有时候我们缓存了太多数据，通常在一台X86的机子上，如果你要缓存的数据超过800M的话，就会出现内存溢出的错误。所以说缓存是有限的。换名话说，你应该估计缓存集的大小，把缓存集的大小限制在10以内，否则它可能会出问题。在Asp.net中，如果缓存过大的话也会报内存溢出错误，特别是如果缓存大的DataSet对象的时候。 你应该认真分析你的程序。根据实际情况来看哪里该用，哪里不该用。如：cache用得过多也会增大服务器的压力。整页输出缓存，又会影响数据的更新。 如果真的需要缓存很大量的数据，可以考虑静态技术。 具体使用：添加cachehelper类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// &lt;summary&gt; /// 缓存帮助类 /// 时间：2016/05/07 /// &lt;/summary&gt; public class CacheHelper &#123; #region 获取数据缓存 /// &lt;summary&gt; /// 获取数据缓存 /// &lt;/summary&gt; /// &lt;param name=&quot;cacheKey&quot;&gt;键&lt;/param&gt; /// &lt;param name=&quot;objObject&quot;&gt;&lt;/param&gt; public static object GetCache(string cacheKey) &#123; var objCache = HttpRuntime.Cache; return objCache[cacheKey]; &#125; #endregion #region 设置数据缓存 /// &lt;summary&gt; /// 设置数据缓存 /// &lt;/summary&gt; public static void SetCache(string cacheKey, object objObject) &#123; var objCache = HttpRuntime.Cache; objCache.Insert(cacheKey, objObject); &#125; /// &lt;summary&gt; /// 设置数据缓存 /// &lt;/summary&gt; public static void SetCache(string cacheKey, object objObject, TimeSpan timeout) &#123; var objCache = HttpRuntime.Cache; objCache.Insert(cacheKey, objObject, null, DateTime.MaxValue, timeout, CacheItemPriority.NotRemovable, null); &#125; /// &lt;summary&gt; /// 设置数据缓存 /// &lt;/summary&gt; public static void SetCache(string cacheKey, object objObject, DateTime absoluteExpiration, TimeSpan slidingExpiration) &#123; var objCache = HttpRuntime.Cache; objCache.Insert(cacheKey, objObject, null, absoluteExpiration, slidingExpiration); &#125; #endregion #region 移除缓存 /// &lt;summary&gt; /// 移除指定数据缓存 /// &lt;/summary&gt; public static void RemoveAllCache(string cacheKey) &#123; var cache = HttpRuntime.Cache; cache.Remove(cacheKey); &#125; /// &lt;summary&gt; /// 移除全部缓存 /// &lt;/summary&gt; public static void RemoveAllCache() &#123; var cache = HttpRuntime.Cache; IDictionaryEnumerator cacheEnum = cache.GetEnumerator(); while (cacheEnum.MoveNext()) &#123; cache.Remove(cacheEnum.Key.ToString()); &#125; &#125; #endregion &#125; 添加完对此进行调用先判断是否已经cache没有则添加1234567891011 var cacheKey = &quot;sid&quot; + assessId + &quot;uid&quot; + studentId + &quot;pindex&quot; + pageHelper.PageIndex; var cachelist = CacheHelper.GetCache(cacheKey) as List&lt;Question&gt;; if (cachelist != null) &#123; return cachelist; &#125;获取数据 var result = GetAssessQuseList(pageHelper, tableName, fields, null, orderBy, true, studentId, otherFields); CacheHelper.SetCache(cacheKey, result, TimeSpan.FromSeconds(120)); return result; 下面是移除cache1234567var cacheKey = &quot;sid&quot; + assessId + &quot;uid&quot; + base.LoggingUser.UserId + &quot;pindex&quot; + pageIndex; var cachelist = CacheHelper.GetCache(cacheKey) as List&lt;Question&gt;; if (cachelist != null) &#123; CacheHelper.RemoveAllCache(cacheKey); &#125;]]></content>
      <categories>
        <category>Asp.Net Mvc</category>
      </categories>
      <tags>
        <tag>Asp.Net Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web 安全整理]]></title>
    <url>%2F2018%2F03%2F07%2FWeb-%E5%AE%89%E5%85%A8%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[概述有过网站开发经验的朋友都知道网站安全是构建网站时必须要考虑的一个因素，网站安全的重点在于服务器的安全配置管理以及程序脚本的完善性。值得注意的是，如果服务器的账号和权限由于管理不善而泄露了，即使技术上网站系统再安全，也不可避免会受到攻击。 在笔者曾经参与过的一个项目中，客户方邀请了专业的第三方安全测试公司进行了安全性的全面检测，同时也针对性地进行了安全性的改善，特别是在应用程序方面。此文将分享改善过程中的几个典型问题的分析和解决对策，包括SQL注入攻击、跨站点脚本攻击、验证码绕过等，希望能够为大家在改善网站安全方面的工作提供参考，并采取相应的防范措施。 常见问题问题1.描述：易受到SQL注入攻击风险：攻击者可以通过应用程序发送数据库命令，这些命令将被服务器执行。这可以用来对数据库进行完全控制。这些SQL注入漏洞可以通过在其中一个区域插入“and 7 = 7 -”或“and 8 = 9 -”，并比较结果进行判断。分析：SQL注入攻击是由于服务器对参数检查不够，而导致攻击者借此获得敏感信息。因此，需要使用参数化查询以确保攻击者无法操作数据库的SQL查询语句。例如，如果应用程序要求输入名称，那它应该只接受字母字符、空格和撇号，而不接受任何其他字符。也就是说，在应用程序中的所有输入域实施服务器端白名单技术。特别是所有用于SQL语句的输入域，需要空格的都应该用引号括起来。改善：在程序中所有可接受外部参数的地方进行逐一识别，以过滤危险字符。如在全局函数中定义“禁止字符串列表”，该表中列出所要过滤出的SQL攻击代码可能包含的字符串。1and |exec |insert |select |delete |update |count | * |chr |mid |master |truncate |char |declare |&lt;|&gt;|’|(|)|&#123;|&#125; 问题2.描述：易受到跨站点脚本攻击风险：此漏洞可以被用来获取身份验证Cookie，攻击管理员账户，或使应用程序的用户攻击其他服务器和系统。该漏洞可以通过在某区域中插入“alert(‘23389950’);”来判断。分析：这也需要在本网站的所有输入域实施服务器端白名单技术。如果需要特殊字符，应该转换为更安全的形式。如适用于各种语言的HTML转码：&amp;应转换为 &amp;；“应转换为”；‘应转换为&amp;39；将&gt;应转换为&gt;；&lt;应转换为&lt;。改善：除了这些标准的HTML转码之外，对于可疑字符串也要进行强化检查和转化，并进一步执行以下操作：（1）对各页面的输入参数进行强化检查；（2）对原来只在客户端判断的参数，在服务器端进一步强化检查;（3）最终提供了全局的转码和过滤的函数。当然这需要在性能和扩展性以及安全性方面的平衡综合考虑。 问题3.描述：非安全的CrossDomain.XML文件风险：为解决Flash/Flex系统中的跨域问题，提出了crossdomain.xml跨域策略文件。虽然可以解决跨域问题，但是也带来了恶意攻击的风险，如果该策略文件里允许访问任何域，就可能允许发起对网络服务器的跨站点请求伪造和跨站点脚本攻击。比如，不安全Flash应用程序可能会访问本地数据和用户保存的网页记录，甚至传播病毒和恶意代码。分析：考虑如何确保只对提供安全资源的可信域开放允许。改善：经过调查，发现在程序目录下的crossdomain.xml文件里的配置如下：123456789&lt;?xml version=”1.0″?&gt;&lt;!DOCTYPE cross-domain-policy SYSTEM ”http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd”&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain=”*” /&gt;&lt;/cross-domain-policy&gt; 文件中的allow-access-from 实体设置为星号设置为允许任何域访问，将其修改为 ，表示只允许本域访问，该问题就解决了。 问题4.描述：网站后台管理通过不安全链接实施风险：管理访问没有强制实施SSL，这可能允许攻击者监视并修改用户和服务器之间的发送的包括账户凭据在内的所有数据。如果攻击者通过代理或者路由软件拦截服务器和管理员间的通信，敏感数据可能被截获，进而管理员账户可能会受到危害。分析：管理访问没有强制实施SSL，为防止数据拦截，管理访问应该强制执行HTTPS (SSL3.0)。改善：运维对服务器进行了配置调整，单独配置支持了SSL3.0访问管理后台。 问题5.描述：验证环节可以被绕过风险：用户发布信息时，虽然有页面的验证码防止自动恶意发布，但仍可能被绕过进行自动提交。绕过的方式之一是使用过滤和识别软件，之二是可以利用Cookie或Session信息绕过验证码。分析：图像失真机制本身不是特别强，可以很容易地使用公开的过滤和识别软件来识别。生成的图片也是可以预测的，因为使用的字符集很简单（只是数字），建议实现一个更强大的验证码系统。Cookie或session信息处理有漏洞导致验证码被绕过, 确保每一个链接只能取得唯一的验证码，并确保每个请求产生并需要一个新的验证码。改善：根据需要增加验证码的复杂度，而不只是单数字。经过分析发现是因为验证码被存入了Session里，而开发人员忘记在提交之后清空Session中的验证码的值，导致验证码在过期时间内一直可用，从而可能被利用多次提交。因此在提交后追加了及时清空验证码的操作。 问题6.描述：泄露敏感信息风险：此信息只能用于协助利用其他漏洞，并不能直接用来破坏应用程序。网站的robots.txt文件里可以获得敏感目录的信息，这可能允许攻击者获得有关应用程序内部的其他信息，这些信息可能被用来攻击其他漏洞。分析：robots.txt不应在提供管理界面的信息。如果robots.txt文件暴露了Web站点结构，则需要将敏感内容移至隔离位置，以避免搜索引擎机器人搜索到此内容。改善：当然robots.txt要根据SEO的要求来处理，但也要同样注意安全性。如：disallow:/testadmin/，其中testadmin为管理后台，就被暴露了。可以根据实际情况是否必要决定删除robots.txt文件或者把敏感目录单独配置禁止搜索引擎搜索。 问题7.描述：密码安全风险：假如某网站数据库泄露，那么用户信息就被一览无余了，如果这是用户的常用密码，那么坏人拿到密码就可以进行撞库操作，那么你买的12306的票就会被坏人退了。以前csdn和天涯就是使用明文来存储密码的，之后就出现的泄露事件。改善：md5加盐加密什么是md5加盐？在存储密码的时候，我们可以将真实的密码+“盐”之后再进行md5加密。“盐”可以是一个字符串（无规律），也可以是一个字段，比如说是姓名字段，也可是是单独的字段。在判断用户是否存在的时候，我们先将输入的密码+“盐”，然后md5加密，在和数据库中的密码字段进行匹配。这样做会安全一些。 问题8.描述：权限控制漏洞风险：未经授权可以进行的操作都是权限控制漏洞例如，某些网站的后台操作就仗着「以为用户不知道入口地址」不进行任何权限检查，又例如，某些操作可能出现不允许更改的字段被用户递交更改（往往是那些网页上标记为 disabled 或者 hidden 的字段），再例如，允许通过 ../ 访问到不应该被访问的文件等（一般存在于 include 中）。改善：所有地方都要进行权限检查（如是否已登录、当前用户是否有足够权限、该项是否可修改等），总之，不要相信任何来自用户的数据，URL 当然也是。 问题9.描述：验证码风险：非一次性、容易被识别。非一次性指的是，同一个验证码可以一直被用下去。一般来说，每进行一次验证码校对（无论正确与否），都应该强制更换或清除 Session 中的验证码。关于识别问题，在当前科技水平下，不加噪点不加扭曲的验证码几乎是 100% 可识别的。改善：使用行为验证方式验证；加干扰线验证 其他问题汇总：问题：可能通过登录页面枚举出用户名，因为根据账户是否存在的错误信息是不同的。对策：修改错误信息使之不带有提示性，如“您输入的邮箱或密码不对!” 并且超过一定次数则对该IP进行锁定。问题：检测到可能泄露敏感信息或被恶意利用的冗余文件，如测试文件、bak文件、临时文件。对策：除去服务器中的相应文件。问题：发现潜在机密信息，如名为order的文件很容易被联想到用户订单。对策：避免在文件名中含有完整的敏感词汇或不要在容易猜测到的文件中保存敏感信息，或者限制对它们的访问。问题：发现内部信息泄露。对策：除去代码中漏删的内部IP地址，内部组织，人员相关信息等。问题：XSS 漏洞，CSRF 漏洞对策：前端安全验证控制参考1：http://blog.csdn.net/lifushan123/article/details/45197753参考2：http://blog.csdn.net/fengyinchao/article/details/50775121]]></content>
      <categories>
        <category>Asp.Net Mvc</category>
      </categories>
      <tags>
        <tag>Asp.Net Mvc,Web 安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET MVC使用EPPlus，导出数据到Excel]]></title>
    <url>%2F2018%2F03%2F02%2FASP-NET-MVC%E4%BD%BF%E7%94%A8EPPlus%EF%BC%8C%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E5%88%B0Excel%2F</url>
    <content type="text"><![CDATA[1.概述如何导出数据到Excel文件中，这里我使用的是免费开源的Epplus组件。源代码下载：https://github.com/caofangsheng93/ExcelExportInMvc 2.介绍这篇文章，介绍的是怎样导出数据到Excel文件中，大多数的后端程序都有报表功能：把显示在Grid中的数据导出到Excel文件中，这篇文章中使用的是EPPlus组件。 EPPlus是一个基于OOXML【Open Extended Markup Language】 格式的，操作Excel表格的类库。OOXML是由微软开发的。默认支持微软的Office。 开源网站：http://epplus.codeplex.com/ 3.正文首先我们需要引入：EPPlus。 实现步骤：1.数据：这里我使用静态数据，来确保这篇文章尽可能通俗易懂。2.集合：静态数据保存在集合中3.DataTable：转化泛型集合的数据，保存到DataTable中4.导出文件：DataTable导出为Excel首先，我们创建一个类：1234567891011121314public class Student&#123; public int ID &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Sex &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Email &#123; get; set; &#125;&#125;Student 然后创建一个静态数据类：123456789101112131415161718public class StaticDataOfStudent&#123; public static List&lt;Student&gt; ListStudent &#123; get &#123; return new List&lt;Student&gt;() &#123; new Student()&#123;ID=1,Name=&quot;曹操&quot;,Sex=&quot;男&quot;,Email=&quot;caocao@163.com&quot;,Age=24&#125;, new Student()&#123;ID=2,Name=&quot;李易峰&quot;,Sex=&quot;女&quot;,Email=&quot;lilingjie@sina.com.cn&quot;,Age=24&#125;, new Student()&#123;ID=3,Name=&quot;张三丰&quot;,Sex=&quot;男&quot;,Email=&quot;zhangsanfeng@qq.com&quot;,Age=224&#125;, new Student()&#123;ID=4,Name=&quot;孙权&quot;,Sex=&quot;男&quot;,Email=&quot;sunquan@163.com&quot;,Age=1224&#125;, &#125;; &#125; &#125;&#125;StaticDataOfStudent 然后就是我们的导出Excel帮助类了： /// /// Excel导出帮助类 /// public class ExcelExportHelper { public static string ExcelContentType { get { return “application/vnd.openxmlformats-officedocument.spreadsheetml.sheet”; } } /// &lt;summary&gt; /// List转DataTable /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static DataTable ListToDataTable&lt;T&gt;(List&lt;T&gt; data) { PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(T)); DataTable dataTable = new DataTable(); for (int i = 0; i &lt; properties.Count; i++) { PropertyDescriptor property = properties[i]; dataTable.Columns.Add(property.Name, Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType); } object[] values = new object[properties.Count]; foreach (T item in data) { for (int i = 0; i &lt; values.Length; i++) { values[i] = properties[i].GetValue(item); } dataTable.Rows.Add(values); } return dataTable; } /// &lt;summary&gt; /// 导出Excel /// &lt;/summary&gt; /// &lt;param name=&quot;dataTable&quot;&gt;数据源&lt;/param&gt; /// &lt;param name=&quot;heading&quot;&gt;工作簿Worksheet&lt;/param&gt; /// &lt;param name=&quot;showSrNo&quot;&gt;//是否显示行编号&lt;/param&gt; /// &lt;param name=&quot;columnsToTake&quot;&gt;要导出的列&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static byte[] ExportExcel(DataTable dataTable, string heading = &quot;&quot;, bool showSrNo = false, params string[] columnsToTake) { byte[] result = null; using(ExcelPackage package=new ExcelPackage()) { ExcelWorksheet workSheet = package.Workbook.Worksheets.Add(string.Format(&quot;{0}Data&quot;, heading)); int startRowFrom = string.IsNullOrEmpty(heading) ? 1 : 3; //开始的行 //是否显示行编号 if (showSrNo) { DataColumn dataColumn = dataTable.Columns.Add(&quot;#&quot;, typeof(int)); dataColumn.SetOrdinal(0); int index = 1; foreach (DataRow item in dataTable.Rows) { item[0] = index; index++; } } //Add Content Into the Excel File workSheet.Cells[&quot;A&quot; + startRowFrom].LoadFromDataTable(dataTable, true); // autofit width of cells with small content int columnIndex = 1; foreach (DataColumn item in dataTable.Columns) { ExcelRange columnCells = workSheet.Cells[workSheet.Dimension.Start.Row, columnIndex, workSheet.Dimension.End.Row, columnIndex]; int maxLength = columnCells.Max(cell =&gt; cell.Value.ToString().Count()); if (maxLength &lt; 150) { workSheet.Column(columnIndex).AutoFit(); } columnIndex++; } // format header - bold, yellow on black using (ExcelRange r = workSheet.Cells[startRowFrom, 1, startRowFrom, dataTable.Columns.Count]) { r.Style.Font.Color.SetColor(System.Drawing.Color.White); r.Style.Font.Bold = true; r.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid; r.Style.Fill.BackgroundColor.SetColor(System.Drawing.ColorTranslator.FromHtml(&quot;#1fb5ad&quot;)); } // format cells - add borders using (ExcelRange r = workSheet.Cells[startRowFrom + 1, 1, startRowFrom + dataTable.Rows.Count, dataTable.Columns.Count]) { r.Style.Border.Top.Style = ExcelBorderStyle.Thin; r.Style.Border.Bottom.Style = ExcelBorderStyle.Thin; r.Style.Border.Left.Style = ExcelBorderStyle.Thin; r.Style.Border.Right.Style = ExcelBorderStyle.Thin; r.Style.Border.Top.Color.SetColor(System.Drawing.Color.Black); r.Style.Border.Bottom.Color.SetColor(System.Drawing.Color.Black); r.Style.Border.Left.Color.SetColor(System.Drawing.Color.Black); r.Style.Border.Right.Color.SetColor(System.Drawing.Color.Black); } // removed ignored columns for (int i = dataTable.Columns.Count - 1; i &gt;= 0; i--) { if (i == 0 &amp;&amp; showSrNo) { continue; } if (!columnsToTake.Contains(dataTable.Columns[i].ColumnName)) { workSheet.DeleteColumn(i + 1); } } if (!String.IsNullOrEmpty(heading)) { workSheet.Cells[&quot;A1&quot;].Value = heading; workSheet.Cells[&quot;A1&quot;].Style.Font.Size = 20; workSheet.InsertColumn(1, 1); workSheet.InsertRow(1, 1); workSheet.Column(1).Width = 5; } result = package.GetAsByteArray(); } return result; } /// &lt;summary&gt; /// 导出Excel /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;heading&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;isShowSlNo&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;ColumnsToTake&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static byte[] ExportExcel&lt;T&gt;(List&lt;T&gt; data, string heading = &quot;&quot;, bool isShowSlNo = false, params string[] ColumnsToTake) { return ExportExcel(ListToDataTable&lt;T&gt;(data), heading, isShowSlNo, ColumnsToTake); } } 到此为止，后端服务器的代码，基本搞完，现在开始设计我们的前端代码： 我们创建一个ViewModel，用来显示数据：12345678910public class StudentViewModel&#123; public List&lt;Student&gt; ListStudent &#123; get &#123; return StaticDataOfStudent.ListStudent; &#125; &#125;&#125; 然后创建一个控制器：1234567891011121314151617public class HomeController : Controller&#123; // GET: Home public ActionResult Index() &#123; StudentViewModel model = new StudentViewModel(); return View(model); &#125; public FileContentResult ExportToExcel() &#123; List&lt;Student&gt; lstStudent = StaticDataOfStudent.ListStudent; string[] columns = &#123; &quot;ID&quot;, &quot;Name&quot;,&quot;Age&quot;&#125;; byte[] filecontent = ExcelExportHelper.ExportExcel(lstStudent,&quot;&quot;, false, columns); return File(filecontent, ExcelExportHelper.ExcelContentType, &quot;MyStudent.xlsx&quot;); &#125;&#125; 视图代码：12345678910111213141516171819202122232425262728293031323334@model ExportToExcel.Models.StudentViewModel@&#123; ViewBag.Title = &quot;Excel文件导出&quot;;&#125;&lt;div class=&quot;panel&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;a href=&quot;@Url.Action(&quot;ExportToExcel&quot;)&quot; class=&quot;btn btn-primary&quot;&gt;Export&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;table class=&quot;table table-striped table-bordered&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Sex&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @foreach (var item in Model.ListStudent) &#123; &lt;tr&gt; &lt;td&gt;@item.ID&lt;/td&gt; &lt;td&gt;@item.Name&lt;/td&gt; &lt;td&gt;@item.Sex&lt;/td&gt; &lt;td&gt;@item.Age&lt;/td&gt; &lt;td&gt;@item.Email&lt;/td&gt; &lt;/tr&gt; &#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt; 效果图：点击Export之后，就导出了Excel文件到浏览器中：打开之后。 总结：这个导出帮助类，可以定制导出那些列。这里我只是导出这三列。123string[] columns = &#123; &quot;ID&quot;, &quot;Name&quot;,&quot;Age&quot;&#125;;byte[] filecontent = ExcelExportHelper.ExportExcel(lstStudent,&quot;&quot;, false, columns);return File(filecontent, ExcelExportHelper.ExcelContentType, &quot;MyStudent.xlsx&quot;); 类似资料参考：http://www.cnblogs.com/liudeyun/p/3535740.html 本文转自： http://www.cnblogs.com/caofangsheng/p/6149843.html]]></content>
      <categories>
        <category>Asp.Net Mvc</category>
      </categories>
      <tags>
        <tag>Asp.Net Mvc,Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10 系统win键不能用]]></title>
    <url>%2F2018%2F03%2F02%2Fwin10-%E7%B3%BB%E7%BB%9Fwin%E9%94%AE%E4%B8%8D%E8%83%BD%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.概述升级Windows10正式版后，还是存在好多问题，最多的问题就是驱动兼容的问题，但今天三皮碰到的这个问题不是驱动问题，而Windows10的一个BUG吧，这个只发生在笔记本电脑上，升级安装Win10后，笔记本触控板没问题，但笔记本键盘失灵没反应、无效不能用。原来我以为是笔记本键盘的驱动兼容问题，所以去查看了笔记本的驱动，一切正常，后来才发现是Windows关机设置中启用快速启动的BUG。 不管是升级还是全新安装，只要是笔记本电脑，这个项目都是默认勾选上了的。所以导致有些笔记本电脑键盘失效不能用。 2.解决方法在任务栏上点击笔记本特有的电源图标。 弹出菜单中点击【电源和睡眠设置】。 在相关设置中选择【其他电脑设置】。 进入电源选项，点击【选择电源按钮的功能】 注意，这里需要点击【更改当前不可用的设置】然后下面的选项才可以修改，不然是灰色的点不动。 这里截出系统原来默认选项，在启用快速启动（推荐）前面是打√的。 将这个√去掉，然后保存修改。 现在重启电脑，键盘就可以使用的了。]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解]]></title>
    <url>%2F2018%2F02%2F23%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述当今web程序的开发技术真是百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX 等等。 无论Web技术在未来如何发展，理解Web程序之间通信的基本协议相当重要, 因为它让我们理解了Web应用程序的内部工作. 本文将对HTTP协议进行详细的实例讲解，内容较多，希望大家耐心看。也希望对大家的开发工作或者测试工作有所帮助。使用Fiddler工具非常方便地捕获HTTP Request和HTTP Response, 关于Fiddler工具的用法，请看我另一篇博客[Fiddler 教程] 阅读目录1. 协议详解 HTTP协议 (一) HTTP协议详解 2.基本认证HTTP协议 (二) 基本认证 3.压缩HTTP协议 (三) 压缩 4.缓存HTTP协议 (四) 缓存 5.代理HTTP协议 (五) 代理 6.状态码详解HTTP协议 (六) 状态码详解 7.CookieHTTP协议 (七) Cookie]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片背景自适应]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[概述最近在做一个项目，要求实现背景自适应，何为背景自适应呢？ 1.如果背景图高度不够，background-size就应该是 auto 100% 2.如果背景图宽度不够，background-size就应该是100% auto 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; id=&quot;viewport&quot; content=&quot;target-densitydpi=1,width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div &#123; position: fixed; top: 0; left: 0; bottom: 0; right: 0; background-image: url(https://bpic.588ku.com/original_origin_min_pic/17/11/28/d2eb2117633c1138cc967a2e7a71ab78.jpg!ww1200); background-position: center 0; background-repeat: no-repeat; background-size: 100% auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var bg_auto_size = function(src) &#123; var dh = document.documentElement.clientHeight; var dw = document.documentElement.clientWidth; var img_url = src; var img = new Image(); img.src = img_url; img.onload = function() &#123; var dRatio = dw / dh; var imgRatio = img.width / img.height; if(dRatio &lt;= imgRatio) &#123; $(&apos;div&apos;).css(&#123; &apos;background-size&apos;: &apos;auto 100%&apos;, &apos;background-position&apos;: &apos;center 0&apos; &#125;); &#125; else &#123; $(&apos;div&apos;).css(&#123; &apos;background-size&apos;: &apos;100% auto&apos;, &apos;background-position&apos;: &apos;center 0&apos; &#125;); &#125; &#125; &#125;; //这个图片的地址必须是绝对路径，如果用相对路径就会报错，文件识别不出，下面路径是我随便找的，不是实际背景的真实绝对路径 var bg = &apos;https://bpic.588ku.com/original_origin_min_pic/17/11/28/d2eb2117633c1138cc967a2e7a71ab78.jpg!ww1200&apos;; bg_auto_size(bg); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js,前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net Core 学习]]></title>
    <url>%2F2018%2F02%2F14%2FNet-Core-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一.概述大型分布式互联网架构开发实战（Docker + SSO + TDD + RabbitMQ + Redis + InfluxDb + Grafana + Metrics + 新一代.NET Core on Linux……），屏幕录制讲解+ 微信群解答两种方式，课程简介 ：http://video.jessetalk.cn/course/5注册时填写 优惠码 3QK54 可获得50元代金券，相当于298-50=248元：http://video.jessetalk.cn/register?inviteCode=3QK54 二.笔记1. 正在学习ing2. 略………]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net,.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些代码记录]]></title>
    <url>%2F2018%2F02%2F14%2F%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.int.TryParse1234567891011121314151617181920/// &lt;summary&gt;/// 批量删除/// &lt;/summary&gt;/// &lt;param name=&quot;ids&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public ActionResult Delete(string ids)&#123; int success = 0; string[] ss = ids.Split(&apos;,&apos;); foreach (var item in ss) &#123; int x; if (int.TryParse(item, out x)) &#123; VideoDAL.Delete(x); success++; &#125; &#125; return Content(&quot;成功删除&quot; + success + &quot;条记录！&quot;);&#125; 2.[ValidateAntiForgeryToken]1234567891011121314[ValidateAntiForgeryToken][HttpPost]public ActionResult Add(VideoMDL model)&#123; if (model.id == 0) &#123; VideoDAL.Insert(model); &#125; else &#123; VideoDAL.Update(model); &#125; return Redirect(&quot;/System/VideoManager/&quot;);&#125; 使用方法：https://www.cnblogs.com/hechunming/p/4647646.html 3.string.Join(“,”, keys.ToArray())使用方法：https://www.cnblogs.com/honghong75042/p/7047817.html 4.jquery绑定事件只执行一次解决办法：12345&lt;input type=&quot;file&quot; value=&quot;&quot; name=&quot;logo_name&quot; id=&quot;logo_name&quot;/&gt;$(document).off(&apos;change&apos;,&apos;#logo_name&apos;).on(&apos;change&apos;,&apos;#logo_name&apos;,function()&#123; alert(&quot;ok&quot;);&#125;); on是绑定了结点，jquery绑定结点的时候只需绑定一次就行了。不能重复绑定，off是将结点移除，移除完之后在重新绑定，这样就可以解决了change执行一次的问题. 5.其他技巧待补充…]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#,小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 使用过程遇到的问题]]></title>
    <url>%2F2018%2F02%2F12%2FHexo-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述问题描述： 在hexo下新建一个MD文件，出现Template render error: unknown path?解决方案：1这个是hexo转义时候发生的错误，你文章中可能出现了&#123;&#123;&#125;&#125;，&#123;% %&#125;。你可以将出现的代码，用 `进行注释下就可以了.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础--浅谈XML读取以及简单的ORM实现]]></title>
    <url>%2F2018%2F02%2F12%2FC-%E5%9F%BA%E7%A1%80-%E6%B5%85%E8%B0%88XML%E8%AF%BB%E5%8F%96%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E7%9A%84ORM%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述背景: 在开发ASP.NETMVC4 项目中,虽然web.config配置满足了大部分需求,不过对于某些特定业务,我们有时候需要添加新的配置文件来记录配置信息,那么XML文件配置无疑是我们选择的一个方案之一。下面简单谈谈XML的读取。 使用一.xml.linq读取xml1.新建一个data.XML文件123456789101112&lt;Customers&gt; &lt;Customer&gt; &lt;Name&gt;Frank&lt;/Name&gt; &lt;City&gt;成都&lt;/City&gt; &lt;Contact&gt;2233&lt;/Contact&gt; &lt;/Customer&gt; &lt;Customer&gt; &lt;Name&gt;Vincent&lt;/Name&gt; &lt;City&gt;美国&lt;/City&gt; &lt;Contact&gt;4455&lt;/Contact&gt; &lt;/Customer&gt;&lt;/Customers&gt; 2.新建customer实体123456public class Customers&#123; public string Name &#123; get; set; &#125; public string City &#123; get; set; &#125; public string Contact &#123; get; set; &#125;&#125; 3.System.Xml.Linq 域名. 就可以轻松将customer信息读取完毕。XDocument.Load读取xml文件. Descendants可以读取Customer节点返回一个集合.再通过Linq的select方法.读取每个Customer节点数据,转换成List对象1234567var customsers = XDocument.Load(&quot;data.xml&quot;).Descendants(&quot;Customer&quot;) .Select(x =&gt; new Customers() &#123; Name = x.Element(&quot;Name&quot;).Value, City = x.Element(&quot;City&quot;).Value, Contact = x.Element(&quot;Contact&quot;).Value, &#125;).ToList(); 二. 简单的ORM上面介绍了XML的读取,那XML读取有没有可以更简单的方式呢. 比如类似于Database的ORM框架. 只需要实体名称与DB SQL的select字段名称一样就会自动映射到实体上面。不需要我们去写代码一个一个去Element上取。 下面我们就来简单实现一个。下面代码只是提供思路:其实我们可以通过反射和打标签来实现, 大家有空不妨去看看小弟写得两篇 打标签和反射的文章。C#基础—Attribute(标签） 和 reflect（反射) 应用C#基础—Attribute(标签） 和 reflect（反射) 应用二 1.新建XmlAttribute类。提供了ElementName属性用于标记实体类字段对应的xml节点12345678public class XmlAttribute : Attribute&#123; public string ElementName &#123; get; set; &#125;&#125; 2. 修改新建的Customler类.ElementName 对应的xml节点名称, 因为有可能开发者xml节点名称和实体名称不一样。1234567891011public class Customers&#123; [Xml(ElementName = &quot;Name&quot;)] public string Name &#123; get; set; &#125; [Xml(ElementName = &quot;City&quot;)] public string City &#123; get; set; &#125; [Xml(ElementName = &quot;Contact&quot;)] public string Contact &#123; get; set; &#125;&#125; 3. 提供XmlReader类,用于读取xml数据(1).先通过反射读取实体,比如Customer类的 字段名称和对应的xml节点名称存入到dic 字典里面.(2).遍历字段，取值赋给实体1234567891011121314151617181920212223242526272829303132333435363738public class XmlReader &#123; public static List&lt;T&gt; ReadList&lt;T&gt;(string filePath,string rootName) where T:class,new () &#123; List&lt;PropertyInfo&gt; propertyInfos = ((T)Activator.CreateInstance(typeof(T))).GetType().GetProperties().ToList(); List&lt;T&gt; result = new List&lt;T&gt;(); var xmlData = XDocument.Load(filePath); //存储实体 属性名称--xml对应节点名称 的key-value值 Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;(); propertyInfos .ForEach(property =&gt; &#123; var attribute = property.GetCustomAttribute(typeof(XmlAttribute)) as XmlAttribute; if (attribute != null) &#123; dic.Add(property.Name, attribute.ElementName); &#125; &#125;); return xmlData .Descendants(rootName) .Select(element =&gt; &#123; // 实例化一个对象 var info = (T)Activator.CreateInstance(typeof(T)); //遍历keyvalue字段,给实体每个字段赋值 foreach (KeyValuePair&lt;string, string&gt; pair in dic) &#123; // 读取对象的filed标签 var attr = info.GetType().GetProperty(pair.Key); attr.SetValue(info, element.Element(pair.Value).Value); &#125; return info; &#125;).ToList(); &#125; &#125; 4.下面看看结果吧, 轻松读取数据了 三. 总结本篇只是简简单单的谈了一下XML读取,xml的类型很多,比如在这些情况也没有考虑。此类情况如果要再次封装。就需要在XmlAttribute类新增一个AttributeName来实现。而且数据类型除开string,还有int，datetime等。以及xml的嵌套，多层解析xml数据等等。网上应该有很多读取xml的框架,我相信很多公司也会有自己的xml读取的框架。虽然没必要重造轮子。但是作为一个开发者还是可以去想想。如果自己要去开发这些公共框架，也应该知道怎么去做，知道可以通过什么方式去实现。 原文引自：http://www.cnblogs.com/FourLeafCloverZc/p/6565589.html]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Select2下拉框总结]]></title>
    <url>%2F2018%2F02%2F12%2FSelect2%E4%B8%8B%E6%8B%89%E6%A1%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、概述组件说明以及API说明：Select2使用示例地址：https://select2.github.io/examples.html Select2参数文档说明：https://select2.github.io/options.html Select2源码：https://github.com/select2/select2 二、组件特性效果展示1、多选效果 2、图文结合的效果 组件使用1、文件需要引入select2.full.js、select2.min.css（4.0.1版本）和jquery.1.8.3及以上最新版本的select2如果引用的jquery版本较低的话，某些功能无法正常使用。比如：清除功能allowClear: true 最新版本请使用标签 2、placeholderplaceholder占位提示文字，如果需要清楚功能，则必须设置placeholder。 3、加载本地数据select2默认的数据属性是id、text，新版本可以自定义，但还是用默认的比较好。所以提供的json中最好转换为id、text形式，当然可以添加其他属性。1234567891011var data = [&#123; id: 0, text: &apos;enhancement&apos; &#125;, &#123; id: 1, text: &apos;bug&apos; &#125;, &#123; id: 2, text: &apos;duplicate&apos; &#125;, &#123; id: 3, text: &apos;invalid&apos; &#125;, &#123; id: 4, text: &apos;wontfix&apos; &#125;];$(&quot;#c01-select&quot;).select2(&#123; data: data, placeholder:&apos;请选择&apos;, allowClear:true&#125;) 4、加载远程数据12345678910111213141516171819202122$(&quot;#c01-select&quot;).select2(&#123; ajax: &#123; url: &quot;data.json&quot;, dataType: &apos;json&apos;, delay: 250, data: function (params) &#123; return &#123; q: params.term, &#125;; &#125;, processResults: function (data) &#123; return &#123; results: data &#125;; &#125;, cache: true &#125;, escapeMarkup: function (markup) &#123; return markup; &#125;, minimumInputLength: 1, templateResult: formatRepo, templateSelection: formatRepoSelection &#125;); 说明：q: params.term 查询参数（params.term表示输入框中内容，q发生到服务器的参数名；所以这里你可以添加自定义参数，如：stype:’person’） processResults中results: data返回数据（返回最终数据给results，如果我的数据在data.res下，则返回data.res。这个与服务器返回json有关） minimumInputLength 最小需要输入多少个字符才进行查询，与之相关的maximumSelectionLength表示最大输入限制。 escapeMarkup字符转义处理 templateResult返回结果回调function formatRepo(repo){return repo.text},这样就可以将返回结果的的text显示到下拉框里，当然你可以return repo.text+”1”;等 templateSelection选中项回调function formatRepoSelection(repo){return repo.text} 关于返回的 json的格式：select2默认json格式为[{id:1,text:’text’},{id:2,text:’text’}]，新版严格要求这样的格式，当然你可以添加列，如：[{id:1,text:’text’,name:’liu’}] 5、获取选中项12345678910var res=$(&quot;#c01-select&quot;).select2(&quot;data&quot;)[0] ; //单选var reslist=$(&quot;#c01-select&quot;).select2(&quot;data&quot;); //多选if(res==undefined)&#123; alert(&quot;你没有选中任何项&quot;);&#125;if(reslist.length)&#123; alert(&quot;你选中任何项&quot;);&#125; 6、清空选择项和设置不可用1234567//清空选择$(&quot;#c01-select&quot;).val(null).trigger(&quot;change&quot;);$(&quot;#c01-select&quot;).val(&quot;你的placeholder&quot;).trigger(&quot;change&quot;);//或者//disabled$(&quot;#c01-select&quot;).prop(&quot;disabled&quot;, false);//可用$(&quot;#c01-select&quot;).prop(&quot;disabled&quot;, true);//不可用 7、启用多选1234$(&quot;#c01-select&quot;).select2(&#123; data:data, multiple: true&#125;); 8、下面简单说明新版与老版对比(1)结果回调和选中回调名称：formatResult、formatSelection（老版）；templateResult、templateSelection（新版） (2)初始化：12345678910//老版，注意如果初始化时文本框中本身没有值（为空），则不会触发该方法initSelection: function (element, callback) &#123; var id = $(element).val(); var data = &#123; id: id, text: id&#125;;//这里是初始化的数据，你可以通过id来从服务器上获取（ajax），再装载进去 callback(data);&#125;//新版，直接给select添加option$(&quot;#id&quot;).append(new Option(&quot;Jquery&quot;, 10001, false, true));//或者$(&quot;#id&quot;).append(&quot;&lt;option value=&apos;10001&apos;&gt;Jquery&lt;/option&gt;&quot;); (3)获取或设置值：12select2(&quot;val&quot;)（老版）；$(&quot;select&quot;).val()（新版） (4)推荐使用123var res = $(&quot;#id&quot;).select2(&quot;data&quot;);//返回数组，单选就取res[0]；好处是不进可以获取id、text还可以获取其他属性，如res[0].names (5)停用或启用：12$(&quot;select&quot;).enable(false);（老版）；$(&quot;select&quot;).prop(&quot;disabled&quot;, true);（新版） (6)主题样式：新版的样式已经更新，但如果想使用老版样式则可以设置 theme: “classic” 项目使用中遇到的问题My Demo实例代码(1)取值字符串的拼接123456789101112131415form.on(&apos;submit(save)&apos;, function (data) &#123; var htmlSelected = []; var reslist = $(&quot;#typeId&quot;).select2(&quot;data&quot;); for (var i = 0; i &lt; reslist.length; i++) &#123; htmlSelected.push($(&apos;#typeId&apos;).select2(&apos;data&apos;)[i].text); &#125; //标签信息。 data.field.Text_Tag = htmlSelected.join(&quot;,&quot;).toString(); $.formSubmit(&#123; url: &quot;/System/ArticleManage/RequestSave&quot;, data: data.field &#125;); return false;&#125;); 说明：放弃以前字符串”+”的拼接方式，改用声明数组，join(“,”)的拼接方式，这样省去字符末尾去空格的问题。性能方面也会比前者好很多。(2)赋值 12345//获取文章标签集合$(&quot;#typeId&quot;).bindSelect(&#123; url: &quot;/System/ArticleManage/GetListTreeSelect&quot;, title: &apos;请选择文章标签&apos;&#125;); Other Demo实例代码(1)取值1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; //取textvar strtext = $(&apos;#select2&apos;).select2(&apos;data&apos;).text;//取valuevar str2value= $(&quot;#select2&quot;).select2(&quot;val&quot;);//多选$(&apos;#select2&apos;).select2(&#123; allowClear: true, data:[&#123;id:0,text:&apos;hello&apos;&#125;,&#123;id:1,text:&apos;world&apos;&#125;]&#125;);&lt;/script&gt;&lt;select id=&quot;select2&quot; &gt; &lt;/select&gt;Select2升级以后，支持多选了，用select2(&apos;data&apos;)取出来是是数组，不在是一个json了，因需要select2(&apos;data&apos;)[0].text 既可以取得对应的值，多个的话循环获取 (2)赋值页面采用razor12345678910111213141516&lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;销售人员：&lt;/label&gt; @Html.DropDownListFor(m =&gt; m.SalesMan, ViewData[&quot;CreateStaffID&quot;] as SelectList, &quot;请选择&quot;, new &#123; @id = &quot;SalesMan&quot;, @class = &quot;select2 &quot;, @style = &quot;width:67%;&quot; &#125;) &lt;span class=&quot;help-line&quot;&gt;@Html.ValidationMessageFor(m =&gt; m.SalesMan)&lt;/span&gt;&lt;/div&gt;js:&lt;script type=&quot;text/javascript&quot;&gt; //示例：给select2标签赋值23 @Html.Raw(&quot;$(&apos;#SalesMan&apos;).val(&quot;23&quot;) $(&quot;#SalesMan&quot;).select2(); &#125;);&lt;/script&gt; 参考原文：http://www.cnblogs.com/liuxiaobo93/p/5112993.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.NET，C#和ASP.NET的关系]]></title>
    <url>%2F2018%2F02%2F08%2FC-%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[概述.NET是一个平台，一个抽象的平台的概念。.NET平台其本身实现的方式其实还是库，抽象层面上来看是一个平台。个人理解.NET核心就只是.NET Framework。.NET Framework包括了两个关键组成元素：Common Language Runtime， 公共语言运行时 －－提供内存管理、代码安全性检测等等功能。.NET Framework Class Library， .NET框架类库 －－提供大量应用类库、提高开发效率。 C#是一个程序设计语言，仅仅是一个语言。运行在.NET(CLR)上的，用于创建应用程序的一种高级编程语言。程序设计语言仅仅是为了方便开发人员和计算机沟通的工具，虽然C#语法相对C和C++要多一些，但是相对来看C#语法都比较固定，这样使用起来却都很容易。 ASP.NET是一个网站开发的技术，仅仅是.NET框架中的一个应用模型。用微软公司ASP.NET快速入门中的一句话来解释，ASP.NET 是用于生成基于 Web 的应用程序的内容丰富的编程框架。 ASP.net和C#的区别：编写asp.net通常包括两部分的代码:网页层和后台处理层.网页就是用标记语言来写的，而网页对应的后台处理程序则需要.net语言来完成，目前主要是采用c#和vb.net可以说整个的asp.net网站通过c#或者vb.net来实现。而c#则是ms .net framework的主要语言，可以用在网站，桌面应用等方面。可以算是一种比较流行的编程语言。 C#能编写什么样的应用程序?桌而应用释详：使用.Net Framework的Windows Presentation Foundation(WPF)模块就可以简便地生成这种程序。 WindowsStore应用程序:WIN8新引入的一类应用程序，针对触摸屏设计，通常全屏运行。 Web应用程序:它们是一些Web页面，可以通过任何Web浏览器查看。可以用C#语言通过Web Forms创建ASP.NET应用程序。 WCF服务:这是一种灵活创建各种分布式应用程巧的方式。使用 WCF服务可以通过局域网或Internet交换几乎各种数据。 .NET的两种交互模式主要有：B/SC/S]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将枚举值转换为DropDownList等的选项值]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%B0%86%E6%9E%9A%E4%B8%BE%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BADropDownList%E7%AD%89%E7%9A%84%E9%80%89%E9%A1%B9%E5%80%BC%2F</url>
    <content type="text"><![CDATA[概述应用场景：在项目中，我们已习惯将较稳定的分类标准定义为枚举，来保证程序中取值的合法性，也使代码更清晰。某些情况下我们需要在DropDownList等选择控件上绑定某个枚举的所有枚举值，供用户自行选择，这时就需要将枚举值转换为DropDownList等的选项值。 应用枚举定义1234567891011121314/// &lt;summary&gt;/// 紧急程度/// &lt;/summary&gt;public enum eOA_EmergencyLevel&#123; /// &lt;summary&gt; /// 平件 /// &lt;/summary&gt; 平件 = 1, /// &lt;summary&gt; /// 急件 /// &lt;/summary&gt; 急件 = 2&#125; 将枚举转换成ArrayList12345678910111213141516/// &lt;summary&gt;/// 将枚举转换成ArrayList/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IList EnumToList(Type enumType)&#123; ArrayList list = new ArrayList(); foreach (int i in Enum.GetValues(enumType)) &#123; ListItem listitem = new ListItem(Enum.GetName(enumType, i), i.ToString()); list.Add(listitem); &#125; return list;&#125; 绑定1234567891011/// &lt;summary&gt;/// 将枚举转换成下拉框/// &lt;/summary&gt;public static void FillDropDownList(DropDownList ddl, Type enumType)&#123; ddl.Items.Clear(); ddl.DataSource = EnumToList(enumType); ddl.DataValueField = &quot;value&quot;; ddl.DataTextField = &quot;text&quot;; ddl.DataBind();&#125; 后来，在同事讨论代码时，被大家批评为不该使用这种中文的枚举名称；同时我自己也觉得这种反射方式性能有问题。不过因为影响不大，一直懒得去理它。 最近看到了两篇博文（枚举的显示和绑定&gt;和一个利用扩展方法的实例：AttachDataExtensions ），是利用C# 3.0的扩展方法实现的，实现得很是优美，可惜我们的项目基于.NET 2.0，用不上。但受此启发，便花了点时间使用Attribute和缓存的技术重构了原来的代码。 改进EnumShowNameAttribute123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// 枚举的显示名称/// &lt;/summary&gt;[global::System.AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]public sealed class EnumShowNameAttribute : Attribute&#123; private string showName; /// &lt;summary&gt; /// 显示名称 /// &lt;/summary&gt; public string ShowName &#123; get &#123; return this.showName; &#125; &#125; /// &lt;summary&gt; /// 构造枚举的显示名称 /// &lt;/summary&gt; /// &lt;param name=&quot;showName&quot;&gt;显示名称&lt;/param&gt; public EnumShowNameAttribute(string showName) &#123; this.showName = showName; &#125;&#125;枚举定义/// &lt;summary&gt;/// 紧急程度/// &lt;/summary&gt;public enum eOA_EmergencyLevel&#123; /// &lt;summary&gt; /// 平件 /// &lt;/summary&gt; [EnumShowName(&quot;平件&quot;)] Common = 1, /// &lt;summary&gt; /// 急件 /// &lt;/summary&gt; [EnumShowName(&quot;急件&quot;)] Emergency = 2&#125; 枚举工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/// &lt;summary&gt;/// 枚举工具类/// &lt;/summary&gt;public sealed class EnumUtil&#123; private static Dictionary&lt;string, Dictionary&lt;int, string&gt;&gt; _EnumList = new Dictionary&lt;string, Dictionary&lt;int, string&gt;&gt;(); //枚举缓存池 /// &lt;summary&gt; /// 将枚举绑定到ListControl /// &lt;/summary&gt; /// &lt;param name=&quot;listControl&quot;&gt;ListControl&lt;/param&gt; /// &lt;param name=&quot;enumType&quot;&gt;枚举类型&lt;/param&gt; public static void FillListControl(ListControl listControl, Type enumType) &#123; listControl.Items.Clear(); listControl.DataSource = EnumToDictionary(enumType); listControl.DataValueField = &quot;key&quot;; listControl.DataTextField = &quot;value&quot;; listControl.DataBind(); &#125; /// &lt;summary&gt; /// 将枚举转换成Dictionary&amp;lt;int, string&amp;gt; /// Dictionary中，key为枚举项对应的int值；value为：若定义了EnumShowName属性，则取它，否则取name /// &lt;/summary&gt; /// &lt;param name=&quot;enumType&quot;&gt;枚举类型&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Dictionary&lt;int, string&gt; EnumToDictionary(Type enumType) &#123; string keyName = enumType.FullName; if (!_EnumList.ContainsKey(keyName)) &#123; Dictionary&lt;int, string&gt; list = new Dictionary&lt;int, string&gt;(); foreach (int i in Enum.GetValues(enumType)) &#123; string name = Enum.GetName(enumType, i); //取显示名称 string showName = string.Empty; object[] atts = enumType.GetField(name).GetCustomAttributes(typeof(EnumShowNameAttribute), false); if (atts.Length &gt; 0) showName = ((EnumShowNameAttribute)atts[0]).ShowName; list.Add(i, string.IsNullOrEmpty(showName) ? name : showName); &#125; object syncObj = new object(); if (!_EnumList.ContainsKey(keyName)) &#123; lock (syncObj) &#123; if (!_EnumList.ContainsKey(keyName)) &#123; _EnumList.Add(keyName, list); &#125; &#125; &#125; &#125; return _EnumList[keyName]; &#125; /// &lt;summary&gt; /// 获取枚举值对应的显示名称 /// &lt;/summary&gt; /// &lt;param name=&quot;enumType&quot;&gt;枚举类型&lt;/param&gt; /// &lt;param name=&quot;intValue&quot;&gt;枚举项对应的int值&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetEnumShowName(Type enumType, int intValue) &#123; return EnumToDictionary(enumType)[intValue]; &#125;&#125; 想更偷懒的话，还可以省掉自定义的EnumShowNameAttribute，直接用System.ComponentModel.DescriptionAttribute就行了。 [附]Enum基础知识：c# 枚举 enum.NET中Flags枚举的使用 关于枚举的种种 (Enumeration FAQ) [C#, IL, BCL] 原文链接：http://www.cnblogs.com/wenjian/archive/2009/06/19/1506550.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C#小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将字符串转换成List]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90List-T%2F</url>
    <content type="text"><![CDATA[概述有时需要将一个字符串分隔后，转换成指定类型的数组或List，比如服务器端收到提交的一组checkbox的值，可能是一个ID串，类似：56,657,0,1,2,3,4,5,6,7,8，需要将它转成一个int数组或List再进行后续处理。 实现可用Array.ConvertAll&lt;/&gt; 泛型方法来实现1234string str = &quot;56,657,0,1,2,3,4,5,6,7,8&quot;;int[] arrInt = Array.ConvertAll&lt;string, int&gt;(str.Split(&apos;,&apos;), s =&gt; int.Parse(s));foreach (int i in arrInt) Console.WriteLine(i); 将这功能做成string的扩展方法12345678910111213public static List&lt;T&gt; ToList&lt;T&gt;(this string str, char split, Converter&lt;string, T&gt; convertHandler)&#123; if (string.IsNullOrEmpty(str)) &#123; return new List&lt;T&gt;(); &#125; else &#123; string[] arr = str.Split(split); T[] Tarr = Array.ConvertAll(arr, convertHandler); return new List&lt;T&gt;(Tarr); &#125;&#125; 调用方法：1List&lt;int&gt; intList = str.ToList&lt;int&gt;(&apos;,&apos;, s =&gt; int.Parse(s));]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C#小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Powerdesigner与数据库同步]]></title>
    <url>%2F2018%2F01%2F30%2FPowerdesigner%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[概述在使用PowerDesigner进行数据库设计、生成数据库，并开发进行一段时间后， 在这段时间内，数据库的结构必然会有一些变化。我们往往会遇到这样的问题，PowerDesigner与现有数据库结构不匹配。如果人工的比较，即费时又会出错。 PowerDesigner 生成数据库由于人工比较的缺陷，我们需要一个工具来解决。首先，因为PowerDesigner文件与数据库文件是完全不同的两种文件格式，所以我们先要将它们转换成同样的数据结构。我们用PowerDesigner的物理模型生成一个新的数据库。以生成SQL SERVER 为例： “Database”-&gt;”Generate Database” 此时数据库设计为Employee表（原始数据库结构）： 然后，在输出目录你会看到SQL脚本文件，新建一个数据库，并执行脚本现在我们改变一些设计，表结构如下（新数据库结构）： 将EmpName的数据类型改为nvarchar(100)， 添加DeptID列。 数据库架构比较工具数据库数据对比工具 SQLDiff（MSSQL版）是针对MS SQLServer的一款小工具，可以针对两个数据进行表结构和数据的对比。 1、结构对比：如开发库和正式库之间的结构和数据同步，此工具可以告诉您哪个表结构有字段的增加减少，或者字段类型的改变，并生成sql进行结构的同步。2、数据对比：如对比两个数据库中的某个表的数据差异，有差异的行会用颜色进行标记，可生成sql脚本进行两个库的同步。下载链接：http://download.csdn.net/download/swordmanli/9629605]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Powerdesigner,工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageOffice_4.2.0.1_ASP.NET MVC开发笔记]]></title>
    <url>%2F2018%2F01%2F30%2FPageOffice-4-2-0-1-ASP-NET-MVC%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[PageOffice开发笔记开发环境：vs2015，mvc，razor使用操作1. 双击运行Setup.exe安装服务器组件。2. 第一次运行包含PageOfficeLink组件的网页时，会弹出注册对话框，请输入注册信息注册。3. 如果新建网站或集成PageOffice到您现有的网站里:拷贝“集成文件”目录下的“pageoffice”文件夹到您自己网站的根目录下； 页面操作前台：1234567891011121314@&#123; ViewBag.Title = &quot;Word&quot;;&#125;&lt;script type=&quot;text/javascript&quot;&gt; function Save() &#123; document.getElementById(&quot;PageOfficeCtrl1&quot;).WebSave(); &#125; &lt;/script&gt;&lt;div style=&quot;width:900px; height:600px;&quot;&gt; @Html.Raw(ViewBag.EditorHtml)&lt;/div&gt; 控制器12345678910111213141516171819202122232425262728293031namespace PageOffice4_MVC_Razor.Controllers&#123; public class WordController : Controller &#123; public void SaveDoc() &#123; ViewBag.Message = &quot;Your app description page.&quot;; string filePath = Server.MapPath(&quot;/test.doc&quot;); PageOffice.FileSaver fs = new PageOffice.FileSaver(); fs.SaveToFile(filePath); fs.Close(); &#125; public ActionResult Word() &#123; ViewBag.Message = &quot;Your contact page.&quot;; PageOffice.PageOfficeCtrl pc = new PageOffice.PageOfficeCtrl(); pc.AddCustomToolButton(&quot;保存&quot;, &quot;Save()&quot;, 1); pc.SaveFilePage = &quot;/Word/SaveDoc&quot;; pc.ServerPage = &quot;/pageoffice/server.aspx&quot;; pc.WebOpen(&quot;/test.doc&quot;, PageOffice.OpenModeType.docAdmin, &quot;s&quot;); ViewBag.EditorHtml = pc.GetHtmlCode(&quot;PageOfficeCtrl1&quot;); return View(); &#125; &#125;&#125; 帮助文档链接：http://www.zhuozhengsoft.com/Technical/]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>MVC,PageOffice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvc4.5从客户端中检测到有潜在危险的 Request.Form 值]]></title>
    <url>%2F2018%2F01%2F29%2Fmvc4-5%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E6%A3%80%E6%B5%8B%E5%88%B0%E6%9C%89%E6%BD%9C%E5%9C%A8%E5%8D%B1%E9%99%A9%E7%9A%84-Request-Form-%E5%80%BC%2F</url>
    <content type="text"><![CDATA[错误截图：今天，在做一个mvc表单提交，其中内容框使用UEditor插件，支持带html文本内容，结果在提交的时候遇到如下提示： 解决方法： webconfig修改： 123&lt;system.web&gt; &lt;httpRuntime targetFramework=&quot;4.5&quot; requestValidationMode=&quot;2.0&quot;/&gt;&lt;/system.web&gt; 请求控制器修改： 123456[ValidateInput(false)][HttpPost] public ActionResult Form(VideoMDL model) &#123; return Json(&quot;OK&quot;, JsonRequestBehavior.AllowGet); &#125; [ValidateInput(false)] 不启用验证（默认为True） 其他Server.HtmlEncode(content)转码，过滤一些字符。]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 常用的快捷键]]></title>
    <url>%2F2018%2F01%2F28%2FSublime-Text-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 快捷键（实用，快速换行等）1.选择类Ctrl+D ：选中光标所占的文本，继续操作则会选中下一个相同的文本。Alt+F3：选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L：选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L ：先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M：选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M：光标移动至括号内结束或开始的位置。Ctrl+Enter：在下一行插入新行。举个例子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter： 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ ：选中代码，按下快捷键，折叠代码。Ctrl+Shift+] ：选中代码，按下快捷键，展开代码。Ctrl+K+0 ：展开所有折叠代码。Ctrl+← ：向左单位性地移动光标，快速移动光标。Ctrl+→ ：向右单位性地移动光标，快速移动光标。shift+↑ ：向上选中多行。shift+↓ ：向下选中多行。Shift+← ：向左选中文本。Shift+→： 向右选中文本。Ctrl+Shift+←：向左单位性地选中文本。Ctrl+Shift+→：向右单位性地选中文本。Ctrl+Shift+↑：将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓：将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑：向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓：向下添加多行光标，可同时编辑多行。 搜索类Ctrl+J：合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D：复制光标所在整行，插入到下一行。Tab：向右缩进。Shift+Tab：向左缩进。Ctrl+K+K：从光标处开始删除代码至行尾。Ctrl+Shift+K：删除整行。Ctrl+/：注释单行。Ctrl+Shift+/ ：注释多行。Ctrl+K+U：转换大写。Ctrl+K+L：转换小写。Ctrl+Z：撤销。Ctrl+Y：恢复撤销。Ctrl+U：软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2：设置书签Ctrl+T：左右字母互换。F6： 单词检测拼写 显示类Ctrl+Tab：按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown：向左切换当前窗口的标签页。Ctrl+PageUp： 向右切换当前窗口的标签页。Alt+Shift+1： 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2： 左右分屏-2列Alt+Shift+3： 左右分屏-3列Alt+Shift+4： 左右分屏-4列Alt+Shift+5： 等分4屏Alt+Shift+8： 垂直分屏-2屏Alt+Shift+9： 垂直分屏-3屏Ctrl+K+B： 开启/关闭侧边栏。F11： 全屏模式Shift+F11：免打扰模式 图解1.选择一个选中项的下一个匹配项: ctrl+d把光标放在一个单词上，按下⌘+ D,将选择这个单词。一直按住⌘且按D多次，将选择当前选中项的下一个匹配项。通过按住⌘,再按D三次,将选择三个相同的文本。 2.选择一个选中项的所有匹配项: alt+f3和上面一样,但它选择文件中的所有匹配项。小心使用这个,因为它能选择一个文件中的所有匹配项. . 3.选择与光标关联的开始和结束标签: ctrl+shift+’这是一个法宝。也许你希望所有属性保持不变,但只是想选择标签。这个快捷键为你这样做,会注意到你可以在一次操作多个标签。需要Emmet插件 4.选择容器内内容: ctrl+shift+a如果你把光标放在文本间再按下上面的键将选择文本,就像ctrl+ D。但是再次按下它，将选择父容器,再按,将选择父容器的父容器。需要Emmet插件 5.选择括号内的内容: ctrl+shift+m这有助于选择括号之间的一切。同样适用于CSS。 6.上移或下移行: ctrl+shift+↑ 或 ↓ 7.复制行或选中项: ctrl+shift+d如果你已经选中了文本,它会复制你的选中项。否则,把光标放在行上,会复制整行。 8.增加和减少缩进: ctrl+[ 或 ] 9.剪切行或选中项: ctrl+x 10.粘贴并保持缩进: ctrl+shift+v这是又一个我每次都用的快捷键。在gif中我显示了普通粘贴(ctrl+ V)和缩进粘贴两种效果的对比。注意缩进如何排列。 11.用标签包裹行或选中项: alt+shift+w使用标签包裹一行; 开始输入你想使用的标签,你成功了. 12.移除未闭合的容器元素: ctrl+shift+;这会移除与你的光标相关的父标签。对清除标记很有帮助。 13.计算数学表达式: ctrl+shift+y我从未想过我会经常使用这个，但是确实很好用 14.递增和递减: alt+shift+↑ 或 ↓，ctrl+ ↑ 或 ↓按住 ↑ 将以10的步长改变数字, 不按住以1为步长. 同时注意到你不需要选择数字, Sublime Text 足够聪明到更新本行最近的数字. 15.大写和小写: ctrl+k+u,ctrl+k+l 16.注释选中项/行: ctrl+/这个在所有语言下都可用, 对行和选中项都可用.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC使用x.PagedList分页]]></title>
    <url>%2F2018%2F01%2F28%2FMVC%E4%BD%BF%E7%94%A8x-PagedList%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[MVC分页 Nuget安装 X.PagedList和X.PagedList.MVCpackage.config文件: 12&lt;package id=&quot;X.PagedList&quot; version=&quot;1.24.1.300&quot; targetFramework=&quot;net45&quot; /&gt;&lt;package id=&quot;X.PagedList.Mvc&quot; version=&quot;4.9.1.310&quot; targetFramework=&quot;net45&quot; /&gt; View界面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@model PagedList.IPagedList&lt;T&gt;@using Model@using PagedList@using PagedList.Mvc&lt;div style=&quot;text-align: center;&quot;&gt; &lt;h1&gt;Mvc分页例子&lt;/h1&gt; &lt;table id=&quot;tbList&quot;&gt; &lt;tbody&gt; @if (Model.Count() != 0) &#123; &lt;tr&gt; &lt;th style=&quot;width: 60px;&quot;&gt;编号&lt;/th&gt; &lt;th style=&quot;width: 150px;&quot;&gt;创建时间&lt;/th&gt; &lt;th style=&quot;width: 200px;&quot;&gt;标题&lt;/th&gt; &lt;th style=&quot;width: 250px;&quot;&gt;内容&lt;/th&gt; &lt;th style=&quot;width: 80px;&quot;&gt;查看次数&lt;/th&gt; &lt;th style=&quot;width: 180px;&quot;&gt;图片&lt;/th&gt; &lt;/tr&gt; foreach (var a in Model) &#123; &lt;tr style=&quot;text-align: center;&quot;&gt; &lt;td&gt;@a.id&lt;/td&gt; &lt;td&gt;@a.createtime&lt;/td&gt; &lt;td&gt;@a.title&lt;/td&gt; &lt;td&gt;@a.body&lt;/td&gt; &lt;td&gt;@a.visitnum&lt;/td&gt; &lt;td&gt;@a.img&lt;/td&gt; &lt;/tr&gt; &#125; &lt;tr&gt; &lt;td colspan=&quot;6&quot;&gt; &lt;div class=&quot;pager&quot;&gt; @if (Model != null) &#123; &lt;span style=&quot;height: 20px; line-height: 20px;&quot;&gt; 共 @Model.TotalItemCount.ToString() 条记录， 当前第 @ViewData[&quot;page&quot;] 页/共 @Model.PageCount 页 &lt;/span&gt; @Html.PagedListPager(Model, page =&gt; Url.Action(&quot;TableByChaJ&quot;, new &#123; page &#125;), new PagedListRenderOptions() &#123; LinkToFirstPageFormat = &quot;首页&quot;, LinkToNextPageFormat = &quot;下一页&quot;, LinkToPreviousPageFormat = &quot;上一页&quot;, LinkToLastPageFormat = &quot;末页&quot;, DisplayItemSliceAndTotal = false, MaximumPageNumbersToDisplay = 3 &#125;) &#125; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 注意：PagedList.IPagedList 中T 改成自己分页的实体类 controller控制器:12345678public ActionResult ActionName(int? page)&#123; int PageNumber = page ?? 1;//page为null时默认值为1 int PageSize = 5; ViewData[&quot;page&quot;] = PageNumber; return View(VideoDAL.GetListPage().ToPagedList(PageNumber, PageSize));&#125; 注意:代码中的list为list 形式，返回视图IPagedList]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>MVC,X.PagedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学使用 Disqus]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%A7%91%E5%AD%A6%E4%BD%BF%E7%94%A8-Disqus%2F</url>
    <content type="text"><![CDATA[科学使用 Disqus详见： http://blog.fooleap.org/use-disqus-correctly.html]]></content>
      <categories>
        <category>Disqus</category>
      </categories>
      <tags>
        <tag>Disqus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dapper使用]]></title>
    <url>%2F2018%2F01%2F23%2Fdapper%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本使用1.连接语句var conn = new SqlConnection(ConfigurationManager.ConnectionStrings[“SqlDiagnosticsDb”].ConnectionString);使用dapper不需要考虑conn是否连接，在执行dapper时自行判断open状态，如果没有打开它会自己打开. 2.insertstring query = “INSERT INTO Book(Name)VALUES(@name)”;conn.Execute(query, book); book类中有name属性，就可以这样方便去写，当然也可以写成 string query = “INSERT INTO Book(Name)VALUES(@name)”;conn.Execute(query, new{@name=book.name}); 3.updatestring query = “UPDATE Book SET Name=@name WHERE id =@id”;conn.Execute(query, book); 4.deletestring query = “DELETE FROM Book WHERE id = @id”;conn.Execute(query, book);conn.Execute(query, new { id = id }); 5.querystring query = “SELECT * FROM Book”;//无参数查询，返回列表，带参数查询和之前的参数赋值法相同.conn.Query(query).ToList(); //返回单条信息string query = “SELECT * FROM Book WHERE id = @id”;book = conn.Query(query, new { id = id }).SingleOrDefault(); 6.传统sql in (1,2,3) 用dapper就这样写conn.Query(“SELECT * FROM Users s WHERE s.id IN (@ids) “,new { ids = new int[]{1,2,3}}) conn.Query(“SELECT * FROM Users s WHERE s.id IN (@ids) “,new { ids = IDs.ToArray()})在dapper因为安全性，不能直接用sql接接，要采用参数化 7.批量插入conn.Execute(@”insert MyTable(colA, colB) values (@a, @b)”, new[] { new { a=1, b=1 }, new { a=2, b=2 }, new { a=3, b=3 } }) 也可以直接写入一个集合conn.Execute(“insert user(name) values(@name)”,users) 这里users是一个user表的对象集合，可一次把集合中的所有数据插入到数据表中. 8.多表查询//查询图书时，同时查找对应的书评，并存在List中。实现1–n的查询操作string query = “SELECT * FROM Book b LEFT JOIN BookReview br ON br.BookId = b.Id WHERE b.id = @id”;Book lookup = null;//Query var b = conn.Query(query, (book, bookReview) =&gt; { //扫描第一条记录，判断非空和非重复 if (lookup == null || lookup.Id != book.Id) lookup = book; //书对应的书评非空，加入当前书的书评List中，最后把重复的书去掉。 if (bookReview != null) lookup.Reviews.Add(bookReview); return lookup; }, new { id = id }).Distinct().SingleOrDefault();return b; 多表联合查询是比较麻烦一些，到现在不是完全明白，多看几个例子var sql = @”select * from Posts p join Users u on u.Id = p.OwnerId Order by p.Id”;var data = conn.Query(sql, (post, user) =&gt; { post.Owner = user; return post;}，splitOn：”id”); Post类和User类,它们存在外键， conn.Query返回的类型是最后一个参数Post, 其中Post中有一属性Owner是User对象，在(post, user)=&gt;lamda中指定了Owner值，上边的代码中的splitOn是ID，运行时，会从查询结果所有字段列表的最后一个字段开始进行匹配，一直到找到Id这个字段（大小写忽略），找到的第一个ID字段匹配User类的ID属性，那么从ID到最后一个字段都属于User，ID以前的字段都被影射到Post， 通过 (post, user) =&gt; { return post;},把两个类的实例解析出来。 9.三表查询，一个是关联主键表（单个对象），一个是关联外键表（集合）。1234567891011121314151617181920212223242526272829303132333435363738394041424344public partial class UserInfo &#123; public UserInfo() &#123; this.Persion = new HashSet&lt;Persion&gt;(); this.MyTYC = new HashSet&lt;MyTYC&gt;(); &#125; public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; public Nullable&lt;System.DateTime&gt; createTime &#123; get; set; &#125; public Movies Movies &#123; get; set; &#125; public virtual ICollection&lt;MyTYC&gt; MyTYC &#123; get; set; &#125; &#125; public class Movies &#123; public int ID &#123; get; set; &#125; public string Title &#123; get; set; &#125; public string ReleaseDate &#123; get; set; &#125; public string Genre &#123; get; set; &#125; public string Price &#123; get; set; &#125; public UserInfo UserInfo &#123; get; set; &#125; &#125; public partial class MyTYC &#123; public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; &#125; string sql = @&quot;select * from UserInfo u inner join [Movies].dbo.Movies m on u.id=m.ID inner join MyTYC t on u.id=t.id&quot;; var data = conn.Query&lt;UserInfo, Movies, MyTYC, UserInfo&gt;(sql, (u, m, t) =&gt; &#123; u.Movies = m; u.MyTYC.Add(t); return u; &#125;); 注意这里的对象和集合的获取方法：u.Movies = m; u.MyTYC.Add(t); 10.多结果查询1234567891011 var sql = @&quot;select * from Customers where CustomerId = @id; select * from Orders where CustomerId = @id; select * from Returns where CustomerId = @id&quot;; using (var multi = connection.QueryMultiple(sql, new &#123;id=selectedId&#125;)) &#123; var customer = multi.Read&lt;Customer&gt;().Single(); var orders = multi.Read&lt;Order&gt;().ToList(); var returns = multi.Read&lt;Return&gt;().ToList(); &#125; 再来一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Program &#123; //创建连接对象 protected static SqlConnection GetConnection() &#123; var connection = new SqlConnection(&quot;Data Source=.;Initial Catalog=TestDB;Integrated Security=True&quot;); connection.Open(); return connection; &#125; static void Main(string[] args) &#123; //测试输出多个结果集 var sql = @&quot;INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;A1&apos;); select @@IDENTITY as A; INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;B1&apos;); select @@IDENTITY as A; INSERT INTO [dbo].[Student] ([Name]) VALUES (&apos;C1&apos;); select @@IDENTITY as A&quot;; //初始化数据库连接 using (SqlConnection connection = GetConnection()) &#123; List&lt;int&gt; ilist = new List&lt;int&gt;(); //执行查询，获取结果集集合 var multi = connection.QueryMultiple(sql); //遍历结果集 while(!multi.IsConsumed) &#123; //读取当前结果集 var result = multi.Read().ToList()[0].A; if (result != null) &#123; ilist.Add(Convert.ToInt32(result)); &#125; &#125; //for(int i = 0;i&lt;3;i++) //&#123; // var result = multi.Read().ToList()[0].A; // if (result != null) // &#123; // ilist.Add(Convert.ToInt32(result)); // &#125; //&#125; foreach (var item in ilist) &#123; Console.WriteLine(item.ToString()); &#125; &#125; Console.ReadLine(); &#125; &#125; 11.支持存储过程USE [Datamip]GO/** Object: StoredProcedure [dbo].[sp_GetUsers] Script Date: 09/02/2016 09:14:04 **/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCreate proc [dbo].[sp_GetUsers] @id intasbeginselect * from Users where UserID = @id ;end 在这里，我们需要向存储过程塞入一个@id参数，返回具体的Users EntityList，好了，下面再看一下Query如何构造。 static void Main(string[] args){ var connection = new SqlConnection(“Data Source=.;Initial Catalog=Datamip;Integrated Security=True;MultipleActiveResultSets=True”); var info = connection.Query(“sp_GetUsers”, new { id = 5 }, commandType: CommandType.StoredProcedure);} 12.如果某一代码中多次操作数据库，可以把conn设置为打开，最后时再close.conn.open()conn.Query(…..…..for….…..conn.close()]]></content>
      <categories>
        <category>ORM</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用.NET 反射机制(Reflecttion)读取和保存Xml配置文档]]></title>
    <url>%2F2018%2F01%2F23%2F%E4%BD%BF%E7%94%A8-NET-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-Reflecttion-%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98Xml%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[原文链接： 定义个一个接口：undefined 将其编译成DLL文件，供其他程序引用。 插件必须编译成DLL文件，可包含多个类，类可以是窗体类型，也可以是控制台类型的。类必须实现上面的接口。 主程序负责显示插件信息，并运行插件。 主程序会生成XML格式的配置文件，使下次访问加快。 下载：http://download.csdn.net/download/rightmin/810378]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dapper的增、删、查改的CodeSmith模板]]></title>
    <url>%2F2018%2F01%2F23%2Fdapper%E7%9A%84%E5%A2%9E%E3%80%81%E5%88%A0%E3%80%81%E6%9F%A5%E6%94%B9%E7%9A%84CodeSmith%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[CodeSmith模板访问量不大的项目我都是用EF写数据库操作，因为EF除了速度上慢以外，但开发效率极快，省略了很多sql写法，并能很方便的调用外键、集合等信息，用EF写项目最爽的事。不过有些项目网站要考虑运行速度，这时不得不用其它的ORM框架，我常用dapper，因为它效果快，而且写sql非常灵活. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;%@ Template Language=&quot;C#&quot; TargetLanguage=&quot;Text&quot; %&gt;&lt;%@ Property Name=&quot;BaseNamespace&quot; Type=&quot;String&quot; %&gt;&lt;%@ Property Name=&quot;SourceDatabase&quot; Type=&quot;SchemaExplorer.DatabaseSchema&quot; Category=&quot;Context&quot; Description=&quot;Database that the documentation should be based on.&quot; %&gt;&lt;%-- 要打印的表 --%&gt;&lt;%@ Property Name=&quot;Table&quot; Type=&quot;TableSchema&quot; DeepLoad=&quot;True&quot; Optional=&quot;False&quot; Category=&quot;Context&quot; Description=&quot;&quot; %&gt; &lt;%@ Assembly Name=&quot;SchemaExplorer&quot; %&gt;&lt;%@ Assembly Name=&quot;System.Design&quot; %&gt;&lt;%@ Import Namespace=&quot;SchemaExplorer&quot; %&gt; using System;using System.Collections.Generic;using System.linq;using System.Text;using &lt;%=BaseNamespace%&gt;.Model;using Dapper;using MayHuan.Data;using System.Collections; namespace &lt;%=BaseNamespace%&gt;.Services&#123; public class &lt;%= Table.Name%&gt;Service:I&lt;%= Table.Name%&gt; &#123; public bool Delete(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;Delete from &lt;%= Table.Name%&gt; where OID=@OID&quot;, new &#123; OID = model.OID &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public bool Insert(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;INSERT INTO &lt;%= Table.Name%&gt; &lt;% System.Text.StringBuilder sbSql=new System.Text.StringBuilder(); %&gt; &lt;% foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(col.Name+&quot;,&quot;); &#125; &#125; %&gt; (&lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt;) VALUES &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(&quot;@&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; (&lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt;)&quot;, &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.Append(col.Name+&quot; = model.&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; new &#123; &lt;%=sbSql.ToString().Trim(&apos;,&apos;) %&gt; &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public bool Update(M&lt;%= Table.Name%&gt; model) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Execute(@&quot;UPDATE &lt;%= Table.Name%&gt; SET &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.AppendLine(col.Name+&quot;=@&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; &lt;%=sbSql.ToString().Trim(&apos;\r&apos;,&apos;\n&apos;,&apos;,&apos;) %&gt; WHERE OID=@OID&quot;, &lt;% sbSql.Clear(); foreach(ColumnSchema col in Table.Columns)&#123; if(!col.IsPrimaryKeyMember)&#123; sbSql.Append(col.Name+&quot; = model.&quot;+col.Name+&quot;,&quot;); &#125; &#125; %&gt; new &#123; &lt;%=sbSql.ToString().Trim(&apos;,&apos;) %&gt;,OID = model.OID &#125;); conn.Close(); return a &gt; 0; &#125; &#125; public M&lt;%= Table.Name%&gt; GetModelByID(int id) &#123; using (var conn = DBCommon.GetConn()) &#123; conn.Open(); var a = conn.Query&lt;M&lt;%= Table.Name%&gt;&gt;(@&quot;select * from &lt;%= Table.Name%&gt; where OID=@OID&quot;, new &#123; OID =id &#125;).FirstOrDefault(); conn.Close(); return a; &#125; &#125; public Model.PageDataView&lt;M&lt;%= Table.Name%&gt;&gt; GetList(string companyName, int pageNum, int pageSize = 10) &#123; var criteria = new PageCriteria(); criteria.CurrentPage = pageNum; criteria.Fields = &quot;a.*&quot;; criteria.PageSize = pageSize; criteria.PrimaryKey = &quot;a.OID&quot;; criteria.TableName = @&quot;&lt;%= Table.Name%&gt; a&quot;; string sqlFilter = &quot;1=1&quot;; if (!string.IsNullOrEmpty(companyName)) sqlFilter += string.Format(&quot; and b.CompanyName like &apos;%&#123;0&#125;%&apos;&quot;, companyName); criteria.Condition += sqlFilter; var r = DBCommon.GetPageData&lt;M&lt;%= Table.Name%&gt;&gt;(criteria); return r; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ORM</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net 用支付宝沙箱环境测试支付接口]]></title>
    <url>%2F2018%2F01%2F21%2Fasp-net-%E7%94%A8%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[沙箱环境的配置1.注册成为开发人员注册成功以后，点击以下链接，进入到支付宝官方的沙箱环境说明：https://docs.open.alipay.com/200/10531 2.沙箱介绍然后点击上图中的沙箱环境，跳转到自己的沙箱环境，配置自己的沙箱环境 。 ## 3.秘钥 至于公钥秘钥的生成，点击 https://docs.open.alipay.com/291/105971 下载生成RSA密钥的工具，操作视频可以搜索该链接：https://openclub.alipay.com/index.php?c=video&amp;fid=76 查看生成秘钥的具体操作步骤。重点是秘钥长度一定要是2048，一定要是2048.当时我测试的时候，生成的1024的，验签通过，但是一上传就提示失败。可见再牛逼的网站也是有bug的。 4.下载支付宝支付demo 打开demo，把配置里面的配置改成自己沙箱账号的配置。支付宝支付demo下载的链接：https://docs.open.alipay.com/54/106682/把配置文件里面的配置改成沙箱 5.下载沙箱钱包进行支付测试，注意不是支付宝哦，详细查看文说明档。，目前沙箱钱包仅提供Android版本，可点击 下载]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端静态文件如何应对HTTPS的到来]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%89%8D%E7%AB%AF%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9HTTPS%E7%9A%84%E5%88%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[原文链接：https://www.cnblogs.com/webARM/p/5728695.html var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/18/前端静态文件如何应对HTTPS的到来', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建评论系统]]></title>
    <url>%2F2018%2F01%2F18%2F%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[基础使用Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 1. 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net ）。 你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。 2. 引入 Gitment将下面的代码添加到你的页面：123456789101112131415&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: &apos;页面 ID&apos;, // 可选。默认为 location.href owner: &apos;你的 GitHub ID&apos;, repo: &apos;存储评论的 repo&apos;, oauth: &#123; client_id: &apos;你的 client ID&apos;, client_secret: &apos;你的 client secret&apos;, &#125;,&#125;)gitment.render(&apos;container&apos;)&lt;/script&gt; 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。 如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。$ npm install –save gitment 3. 初始化评论页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。 之后其他用户即可在该页面发表评论。 自定义Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能） 比如你可以通过自定义主题将评论框放在评论列表前面：1234567891011121314151617const myTheme = &#123; render(state, instance) &#123; const container = document.createElement(&apos;div&apos;) container.lang = &quot;en-US&quot; container.className = &apos;gitment-container gitment-root-container&apos; container.appendChild(instance.renderHeader(state, instance)) container.appendChild(instance.renderEditor(state, instance)) container.appendChild(instance.renderComments(state, instance)) container.appendChild(instance.renderFooter(state, instance)) return container &#125;,&#125;const gitment = new Gitment(&#123; // ... theme: myTheme,&#125;)gitment.render(&apos;container&apos;) 原文链接：https://imsun.net/posts/gitment-introduction/ var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/18/搭建评论系统', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>GitHub Issues</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探-Hexo]]></title>
    <url>%2F2018%2F01%2F16%2F%E5%88%9D%E6%8E%A2-Hexo%2F</url>
    <content type="text"><![CDATA[使用Hexo+Github一步步搭建属于自己的博客 相关步骤：1.安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面输入npm install hexo -g，开始安装Hexo输入hexo -v，检查hexo是否安装成功输入hexo init，初始化该文件夹（有点漫长的等待。。。）看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件输入hexo g，首次体验Hexo输入hexo s，开启服务器，访问该网址，正式体验Hexo问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent登录Github，点击头像下的settings，添加ssh新建一个new ssh key，将id_rsa.pub文件里的内容复制上去输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com” 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名”这时候在文件夹_posts目录下将会看到已经创建的文件在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章到此为止，最基本的也是最全面的hexo+github搭建博客完结。 原文引自：http://www.cnblogs.com/fengxiongZz/p/7707219.html其他参考：https://segmentfault.com/a/1190000009544924其他参考：http://blog.csdn.net/u010053344/article/details/50701191NexT配置：http://theme-next.iissnan.com/ var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/16/初探-Hexo', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 高级配置]]></title>
    <url>%2F2018%2F01%2F16%2FHexo-%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Site 网站title: 为学 网站标题subtitle: 天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。 #网站副标题description: 天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。 #网站描述author: willxue #您的名字language: zh-CN #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区 URL 网址url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults: Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace: var gitment = new Gitment({ owner: 'haimianbao1111', repo: '2018/01/16/Hexo-高级配置', oauth: { client_id: '24f4cb2732b2cd293c3c', client_secret: '54ad1cb8fc1bbab13871b8b9dd01004340aceca0', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
